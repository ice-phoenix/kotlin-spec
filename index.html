<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Kotlin language specification</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="index.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script src="index.js"></script>
</head>
<body>
<header>
<h1 class="title">Kotlin language specification</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#glossary">Glossary</a></li>
<li><a href="#kotlincore">Kotlin/Core</a><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#syntax">Syntax</a><ul>
<li><a href="#grammar">Grammar</a><ul>
<li><a href="#lexical-grammar">Lexical grammar</a><ul>
<li><a href="#character-classes">Character classes</a></li>
<li><a href="#keywords-and-operators">Keywords and operators</a></li>
<li><a href="#whitespace-and-comments">Whitespace and comments</a></li>
<li><a href="#number-literals">Number literals</a></li>
<li><a href="#identifiers">Identifiers</a></li>
<li><a href="#string-literals">String literals</a></li>
<li><a href="#misc">Misc</a></li>
</ul></li>
<li><a href="#syntax-grammar">Syntax grammar</a></li>
</ul></li>
</ul></li>
<li><a href="#type-system">Type system</a><ul>
<li><a href="#glossary-1">Glossary</a></li>
<li><a href="#introduction-1">Introduction</a></li>
<li><a href="#type-kinds">Type kinds</a><ul>
<li><a href="#built-in-types">Built-in types</a><ul>
<li><a href="#kotlin.any"><code>kotlin.Any</code></a></li>
<li><a href="#kotlin.nothing"><code>kotlin.Nothing</code></a></li>
<li><a href="#kotlin.unit"><code>kotlin.Unit</code></a></li>
<li><a href="#kotlin.function"><code>kotlin.Function</code></a></li>
</ul></li>
<li><a href="#classifier-types">Classifier types</a><ul>
<li><a href="#simple-classifier-types">Simple classifier types</a></li>
<li><a href="#parameterized-classifier-types">Parameterized classifier types</a></li>
<li><a href="#type-parameters">Type parameters</a><ul>
<li><a href="#bounded-type-parameters">Bounded type parameters</a></li>
<li><a href="#mixed-site-variance">Mixed-site variance</a></li>
<li><a href="#declaration-site-variance">Declaration-site variance</a></li>
<li><a href="#use-site-variance">Use-site variance</a></li>
</ul></li>
<li><a href="#type-capturing">Type capturing</a></li>
</ul></li>
<li><a href="#function-types">Function types</a></li>
<li><a href="#array-types">Array types</a></li>
<li><a href="#flexible-types">Flexible types</a><ul>
<li><a href="#platform-types">Platform types</a></li>
</ul></li>
<li><a href="#nullable-types">Nullable types</a></li>
<li><a href="#intersection-types">Intersection types</a><ul>
<li><a href="#type-intersection">Type intersection</a></li>
</ul></li>
</ul></li>
<li><a href="#subtyping">Subtyping</a><ul>
<li><a href="#subtyping-rules">Subtyping rules</a></li>
<li><a href="#subtyping-for-flexible-types">Subtyping for flexible types</a></li>
<li><a href="#subtyping-for-intersection-types">Subtyping for intersection types</a></li>
<li><a href="#subtyping-for-nullable-types">Subtyping for nullable types</a></li>
</ul></li>
<li><a href="#generics">Generics</a></li>
<li><a href="#upper-and-lower-bounds">Upper and lower bounds</a><ul>
<li><a href="#least-upper-bound">Least upper bound</a></li>
<li><a href="#greatest-lower-bound">Greatest lower bound</a></li>
</ul></li>
<li><a href="#references">References</a></li>
</ul></li>
<li><a href="#built-in-classifier-types">Built-in classifier types</a><ul>
<li><a href="#kotlin.boolean"><code>kotlin.Boolean</code></a></li>
<li><a href="#built-in-integer-types">Built-in integer types</a></li>
<li><a href="#built-in-floating-point-arithmetic-types">Built-in floating point arithmetic types</a></li>
<li><a href="#kotlin.char"><code>kotlin.Char</code></a></li>
<li><a href="#kotlin.string"><code>kotlin.String</code></a></li>
</ul></li>
<li><a href="#runtime-type-information">Runtime type information</a><ul>
<li><a href="#runtime-available-types">Runtime-available types</a></li>
</ul></li>
<li><a href="#scopes-and-identifiers">Scopes and identifiers</a></li>
<li><a href="#packages-and-imports">Packages and imports</a><ul>
<li><a href="#importing">Importing</a></li>
<li><a href="#modules">Modules</a></li>
</ul></li>
<li><a href="#overloadable-operators">Overloadable operators</a></li>
<li><a href="#declarations">Declarations</a><ul>
<li><a href="#glossary-2">Glossary</a></li>
<li><a href="#identifiers-names-and-paths">Identifiers, names and paths</a></li>
<li><a href="#introduction-2">Introduction</a></li>
<li><a href="#classifier-declaration">Classifier declaration</a><ul>
<li><a href="#class-declaration">Class declaration</a><ul>
<li><a href="#constructor-declaration">Constructor declaration</a></li>
<li><a href="#nested-and-inner-classifiers">Nested and inner classifiers</a></li>
<li><a href="#inheritance-delegation">Inheritance delegation</a></li>
</ul></li>
<li><a href="#data-class-declaration">Data class declaration</a><ul>
<li><a href="#data-class-generation">Data class generation</a></li>
</ul></li>
<li><a href="#enum-class-declaration">Enum class declaration</a></li>
<li><a href="#annotation-class-declaration">Annotation class declaration</a></li>
<li><a href="#interface-declaration">Interface declaration</a></li>
<li><a href="#object-declaration">Object declaration</a></li>
<li><a href="#classifier-initialization">Classifier initialization</a></li>
</ul></li>
<li><a href="#function-declaration">Function declaration</a><ul>
<li><a href="#named-positional-and-default-parameters">Named, positional and default parameters</a></li>
<li><a href="#variable-length-parameters">Variable length parameters</a></li>
<li><a href="#extension-function-declaration">Extension function declaration</a></li>
</ul></li>
<li><a href="#property-declaration">Property declaration</a><ul>
<li><a href="#read-only-property-declaration">Read-only property declaration</a></li>
<li><a href="#mutable-property-declaration">Mutable property declaration</a></li>
<li><a href="#delegated-property-declaration">Delegated property declaration</a></li>
<li><a href="#local-property-declaration">Local property declaration</a></li>
<li><a href="#getters-and-setters">Getters and setters</a></li>
<li><a href="#extension-property-declaration">Extension property declaration</a></li>
<li><a href="#property-initialization">Property initialization</a></li>
</ul></li>
<li><a href="#type-alias">Type alias</a></li>
<li><a href="#declarations-with-type-parameters">Declarations with type parameters</a></li>
<li><a href="#declaration-modifiers">Declaration modifiers</a></li>
</ul></li>
<li><a href="#statements">Statements</a><ul>
<li><a href="#assignments">Assignments</a><ul>
<li><a href="#simple-assignments">Simple assignments</a></li>
<li><a href="#operator-assignments">Operator assignments</a></li>
</ul></li>
<li><a href="#loop-statements">Loop statements</a><ul>
<li><a href="#while-loop-statement">While-loop statement</a></li>
<li><a href="#do-while-loop-statement">Do-while-loop statement</a></li>
<li><a href="#for-loop-statement">For-loop statement</a></li>
</ul></li>
<li><a href="#code-blocks">Code blocks</a></li>
<li><a href="#todo">TODO</a></li>
</ul></li>
<li><a href="#expressions">Expressions</a><ul>
<li><a href="#glossary-3">Glossary</a></li>
<li><a href="#introduction-3">Introduction</a></li>
<li><a href="#constant-literals">Constant literals</a><ul>
<li><a href="#boolean-literals">Boolean literals</a></li>
<li><a href="#integer-literals">Integer literals</a><ul>
<li><a href="#decimal-integer-literals">Decimal integer literals</a></li>
<li><a href="#hexadecimal-integer-literals">Hexadecimal integer literals</a></li>
<li><a href="#binary-integer-literals">Binary integer literals</a></li>
<li><a href="#long-integer-literals">Long integer literals</a></li>
</ul></li>
<li><a href="#real-literals">Real literals</a></li>
<li><a href="#character-literals">Character literals</a></li>
<li><a href="#string-literals-1">String literals</a></li>
<li><a href="#null-literal">Null literal</a></li>
</ul></li>
<li><a href="#try-expression">Try-expression</a></li>
<li><a href="#conditional-expression">Conditional expression</a></li>
<li><a href="#when-expression">When expression</a><ul>
<li><a href="#exhaustive-when-expressions">Exhaustive when expressions</a></li>
</ul></li>
<li><a href="#logical-disjunction-expression">Logical disjunction expression</a></li>
<li><a href="#logical-conjunction-expression">Logical conjunction expression</a></li>
<li><a href="#equality-expressions">Equality expressions</a><ul>
<li><a href="#reference-equality-expressions">Reference equality expressions</a></li>
<li><a href="#value-equality-expressions">Value equality expressions</a></li>
</ul></li>
<li><a href="#comparison-expressions">Comparison expressions</a></li>
<li><a href="#type-checking-and-containment-checking-expressions">Type-checking and containment-checking expressions</a><ul>
<li><a href="#type-checking-expression">Type-checking expression</a></li>
<li><a href="#containment-checking-expression">Containment-checking expression</a></li>
</ul></li>
<li><a href="#elvis-operator-expression">Elvis operator expression</a></li>
<li><a href="#range-expression">Range expression</a></li>
<li><a href="#additive-expression">Additive expression</a></li>
<li><a href="#multiplicative-expression">Multiplicative expression</a></li>
<li><a href="#cast-expression">Cast expression</a></li>
<li><a href="#prefix-expressions">Prefix expressions</a><ul>
<li><a href="#annotated-and-labeled-expression">Annotated and labeled expression</a></li>
<li><a href="#prefix-increment-expression">Prefix increment expression</a></li>
<li><a href="#prefix-decrement-expression">Prefix decrement expression</a></li>
<li><a href="#unary-minus-expression">Unary minus expression</a></li>
<li><a href="#unary-plus-expression">Unary plus expression</a></li>
<li><a href="#logical-not-expression">Logical not expression</a></li>
</ul></li>
<li><a href="#postfix-operator-expressions">Postfix operator expressions</a><ul>
<li><a href="#postfix-increment-expression">Postfix increment expression</a></li>
<li><a href="#postfix-decrement-expression">Postfix decrement expression</a></li>
</ul></li>
<li><a href="#not-null-assertion-expression">Not-null assertion expression</a></li>
<li><a href="#indexing-expressions">Indexing expressions</a></li>
<li><a href="#call-and-property-access-expressions">Call and property access expressions</a><ul>
<li><a href="#navigation-operators">Navigation operators</a></li>
</ul></li>
<li><a href="#function-literals">Function literals</a><ul>
<li><a href="#anonymous-function-declarations">Anonymous function declarations</a></li>
<li><a href="#lambda-literals">Lambda literals</a></li>
</ul></li>
<li><a href="#object-literals">Object literals</a></li>
<li><a href="#this-expressions">This-expressions</a></li>
<li><a href="#super-forms">Super-forms</a></li>
<li><a href="#jump-expressions">Jump expressions</a><ul>
<li><a href="#throw-expressions">Throw expressions</a></li>
<li><a href="#return-expressions">Return expressions</a></li>
<li><a href="#continue-expression">Continue expression</a></li>
<li><a href="#break-expression">Break expression</a></li>
</ul></li>
<li><a href="#string-interpolation-expressions">String interpolation expressions</a></li>
<li><a href="#operator-expressions">Operator expressions</a></li>
</ul></li>
<li><a href="#todos">TODOs()</a></li>
<li><a href="#order-of-evaluation">Order of evaluation</a></li>
<li><a href="#semantics">Semantics</a></li>
<li><a href="#control--and-data-flow-analysis">Control- and data-flow analysis</a></li>
<li><a href="#kotlin-type-constraints">Kotlin type constraints</a><ul>
<li><a href="#type-constraint-definition">Type constraint definition</a></li>
<li><a href="#type-constraint-solving">Type constraint solving</a><ul>
<li><a href="#checking-constraint-system-soundness">Checking constraint system soundness</a></li>
<li><a href="#finding-optimal-solution">Finding optimal solution</a></li>
</ul></li>
</ul></li>
<li><a href="#type-inference">Type inference</a><ul>
<li><a href="#smart-casts">Smart casts</a></li>
<li><a href="#local-type-inference">Local type inference</a></li>
<li><a href="#todo-1">TODO</a></li>
</ul></li>
<li><a href="#overload-resolution">Overload resolution</a><ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#receivers">Receivers</a></li>
<li><a href="#the-forms-of-call-expression">The forms of call-expression</a></li>
<li><a href="#callables-and-invoke-convention">Callables and <code>invoke</code> convention</a></li>
<li><a href="#overload-resolution-for-a-fully-qualified-call">Overload resolution for a fully-qualified call</a></li>
<li><a href="#a-call-with-an-explicit-receiver">A call with an explicit receiver</a></li>
<li><a href="#infix-function-calls">Infix function calls</a></li>
<li><a href="#operator-calls">Operator calls</a></li>
<li><a href="#a-call-without-an-explicit-receiver">A call without an explicit receiver</a></li>
<li><a href="#calls-with-named-parameters">Calls with named parameters</a></li>
<li><a href="#calls-with-trailing-lambda-expressions">Calls with trailing lambda expressions</a></li>
<li><a href="#calls-with-specified-type-parameters">Calls with specified type parameters</a></li>
<li><a href="#determining-function-applicability-for-a-specific-call">Determining function applicability for a specific call</a><ul>
<li><a href="#rationale">Rationale</a></li>
<li><a href="#description">Description</a></li>
</ul></li>
<li><a href="#choosing-the-most-specific-function-from-the-overload-candidate-set">Choosing the most specific function from the overload candidate set</a><ul>
<li><a href="#rationale-1">Rationale</a></li>
<li><a href="#description-1">Description</a></li>
</ul></li>
<li><a href="#about-type-inference">About type inference</a><ul>
<li><a href="#todos-1">TODOs</a></li>
</ul></li>
</ul></li>
<li><a href="#concurrency">Concurrency</a></li>
<li><a href="#coroutines">Coroutines</a></li>
<li><a href="#annotations">Annotations</a></li>
<li><a href="#documentation-comments">Documentation comments</a></li>
<li><a href="#fubar">FUBAR</a></li>
<li><a href="#exceptions">Exceptions</a></li>
</ul></li>
</ul>
</nav>

<h1 id="glossary">Glossary</h1>
<div class="paragraph">
<p><span class="sentence">w.r.t.:: with respect to</span></p>
</div>
<h1 id="kotlincore">Kotlin/Core</h1>
<h2 id="introduction">Introduction</h2>
<div class="paragraph">
<p><span class="sentence">Here be dragonsâ€¦</span></p>
</div>
<h2 id="syntax">Syntax</h2>
<h3 id="grammar">Grammar</h3>
<h4 id="lexical-grammar">Lexical grammar</h4>
<h5 id="character-classes">Character classes</h5>
<div id="grammar-rule-LF" class="grammar-rule">
<dl>
<dt><strong><em>LF</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;unicode character Line Feed U+000A&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-CR" class="grammar-tule">
<dl>
<dt><strong><em>CR</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;unicode character Carriage Return U+000D&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-WS" class="grammar-tule">
<dl>
<dt><strong><em>WS</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;one of the following characters: SPACE U+0020, TAB U+0009, Form Feed U+000C&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-Underscore" class="grammar-tule">
<dl>
<dt><strong><em>Underscore</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;unicode character Low Line U+005F&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-Letter" class="grammar-tule">
<dl>
<dt><strong><em>Letter</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;any unicode character from classes Ll, Lm, Lo, Lt, Lu or Nl&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-UnicodeDigit" class="grammar-tule">
<dl>
<dt><strong><em>UnicodeDigit</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;any unicode character from class Nd&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-LineCharacter" class="grammar-tule">
<dl>
<dt><strong><em>LineCharacter</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;any unicode character excluding LF and CR&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-BinaryDigit" class="grammar-tule">
<dl>
<dt><strong><em>BinaryDigit</em>:</strong></dt>
<dd><span class="sentence"><code>'0'</code> | <code>'1'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-DecimalDigit" class="grammar-tule">
<dl>
<dt><strong><em>DecimalDigit</em>:</strong></dt>
<dd><span class="sentence"><code>'0'</code> | <code>'1'</code> | <code>'2'</code> | <code>'3'</code> | <code>'4'</code> | <code>'5'</code> | <code>'6'</code> | <code>'7'</code> | <code>'8'</code> | <code>'9'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-HexDigit" class="grammar-tule">
<dl>
<dt><strong><em>HexDigit</em>:</strong></dt>
<dd><span class="sentence"><em>DecimalDigit</em><br />
| <code>'A'</code> | <code>'B'</code> | <code>'C'</code> | <code>'D'</code> | <code>'E'</code> | <code>'F'</code><br />
| <code>'a'</code> | <code>'b'</code> | <code>'c'</code> | <code>'d'</code> | <code>'e'</code> | <code>'f'</code></span>
</dd>
</dl>
</div>
<h5 id="keywords-and-operators">Keywords and operators</h5>
<dl>
<dt><strong><em>Operator</em>:</strong></dt>
<dd><span class="sentence"><code>'.'</code> | <code>','</code> | <code>'('</code> | <code>')'</code> | <code>'['</code> | <code>']'</code> | <code>'@['</code> | <code>'{'</code> | <code>'}'</code> | <code>'*'</code> | <code>'%'</code> | <code>'/'</code> | <code>'+'</code> | <code>'-'</code> | <code>'++'</code> | <code>'--'</code><br />
| <code>'&amp;&amp;'</code> | <code>'||'</code> | <code>'!'</code> | <code>'!!'</code> | <code>':'</code> | <code>';'</code> | <code>'='</code> | <code>'+='</code> | <code>'-='</code> | <code>'*='</code> | <code>'/='</code> | <code>'%='</code> | <code>'-&gt;'</code> | <code>'=&gt;'</code><br />
| <code>'..'</code> | <code>'::'</code> | <code>'?::'</code> | <code>';;'</code> | <code>'#'</code> | <code>'@'</code> | <code>'?'</code> | <code>'?:'</code> | <code>'&lt;'</code> | <code>'&gt;'</code> | <code>'\m'</code> | <code>'&gt;='</code> | <code>'!='</code> | <code>'!=='</code><br />
| <code>'=='</code> | <code>'==='</code> | <code>'''</code> | <code>'&quot;'</code> | <code>'&quot;&quot;&quot;'</code></span>
</dd>
<dt><strong><em>SoftKeyword</em>:</strong></dt>
<dd><span class="sentence"><code>'public'</code> | <code>'private'</code> | <code>'protected'</code> | <code>'internal'</code><br />
| <code>'enum'</code> | <code>'sealed'</code> | <code>'annotation'</code> | <code>'data'</code> | <code>'inner'</code><br />
| <code>'tailrec'</code> | <code>'operator'</code> | <code>'inline'</code> | <code>'infix'</code> | <code>'external'</code><br />
| <code>'suspend'</code> | <code>'override'</code> | <code>'abstract'</code> | <code>'final'</code> | <code>'open'</code><br />
| <code>'const'</code> | <code>'lateinit'</code> | <code>'vararg'</code> | <code>'noinline'</code> | <code>'crossinline'</code><br />
| <code>'reified'</code> | <code>'expect'</code> | <code>'actual'</code></span>
</dd>
<dt><strong><em>Keyword</em>:</strong></dt>
<dd><span class="sentence"><code>'package'</code> | <code>'import'</code> | <code>'class'</code> | <code>'interface'</code><br />
| <code>'fun'</code> | <code>'object'</code> | <code>'val'</code> | <code>'var'</code> | <code>'typealias'</code><br />
| <code>'constructor'</code> | <code>'by'</code> | <code>'companion'</code> | <code>'init'</code><br />
| <code>'this'</code> | <code>'super'</code> | <code>'typeof'</code> | <code>'where'</code><br />
| <code>'if'</code> | <code>'else'</code> | <code>'when'</code> | <code>'try'</code> | <code>'catch'</code><br />
| <code>'finally'</code> | <code>'for'</code> | <code>'do'</code> | <code>'while'</code> | <code>'throw'</code><br />
| <code>'return'</code> | <code>'continue'</code> | <code>'break'</code> | <code>'as'</code><br />
| <code>'is'</code> | <code>'in'</code> | <code>'!is'</code> | <code>'!in'</code> | <code>'out'</code><br />
| <code>'get'</code> | <code>'set'</code> | <code>'dynamic'</code> | <code>'@file'</code><br />
| <code>'@field'</code> | <code>'@property'</code> | <code>'@get'</code> | <code>'@set'</code><br />
| <code>'@receiver'</code> | <code>'@param'</code> | <code>'@setparam'</code> | <code>'@delegate'</code></span>
</dd>
</dl>
<h5 id="whitespace-and-comments">Whitespace and comments</h5>
<div id="grammar-rule-NL" class="grammar-tule">
<dl>
<dt><strong><em>NL</em>:</strong></dt>
<dd><span class="sentence"><em>LF</em> | <em>CR</em> [<em>LF</em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-ShebangLine" class="grammar-tule">
<dl>
<dt><strong><em>ShebangLine</em>:</strong></dt>
<dd><span class="sentence"><code>'#!'</code> {<em>LineCharacter</em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-LineComment" class="grammar-tule">
<dl>
<dt><strong><em>LineComment</em>:</strong></dt>
<dd><span class="sentence"><code>'//'</code> {<em>LineCharacter</em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-DelimitedComment" class="grammar-tule">
<dl>
<dt><strong><em>DelimitedComment</em>:</strong></dt>
<dd><span class="sentence"><code>'/*'</code> {<em>DelimitedComment</em> | &lt;any character&gt;} <code>'*/'</code></span>
</dd>
</dl>
</div>
<h5 id="number-literals">Number literals</h5>
<div id="grammar-rule-RealLiteral" class="grammar-tule">
<dl>
<dt><strong><em>RealLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>FloatLiteral</em> | <em>DoubleLiteral</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-FloatLiteral" class="grammar-tule">
<dl>
<dt><strong><em>FloatLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>DoubleLiteral</em> (<code>'f'</code> | <code>'F'</code>) | <em>DecDigits</em> (<code>'f'</code> | <code>'F'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-DoubleLiteral" class="grammar-tule">
<dl>
<dt><strong><em>DoubleLiteral</em>:</strong></dt>
<dd><span class="sentence">[<em>DecDigits</em>] <code>'.'</code> <em>DecDigits</em> [<em>DoubleExponent</em>] | <em>DecDigits</em> <em>DoubleExponent</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-LongLiteral" class="grammar-tule">
<dl>
<dt><strong><em>LongLiteral</em>:</strong></dt>
<dd><span class="sentence">(<em>IntegerLiteral</em> | <em>HexLiteral</em> | <em>BinLiteral</em>) <code>'L'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-IntegerLiteral" class="grammar-tule">
<dl>
<dt><strong><em>IntegerLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigitNoZero</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-HexLiteral" class="grammar-tule">
<dl>
<dt><strong><em>HexLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'0'</code> (<code>'x'</code>|<code>'X'</code>) <em>HexDigit</em> {<em>HexDigitOrSeparator</em>} <em>HexDigit</em><br />
| <code>'0'</code> (<code>'x'</code>|<code>'X'</code>) <em>HexDigit</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-BinLiteral" class="grammar-tule">
<dl>
<dt><strong><em>BinLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'0'</code> (<code>'b'</code>|<code>'B'</code>) <em>BinDigit</em> {<em>BinDigitOrSeparator</em>} <em>BinDigit</em><br />
| <code>'0'</code> (<code>'b'</code>|<code>'B'</code>) <em>BinDigit</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-DegDigitNoZero" class="grammar-tule">
<dl>
<dt><strong><em>DecDigitNoZero</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> - <code>'0'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-DecDigitOrSeparator" class="grammar-tule">
<dl>
<dt><strong><em>DecDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> | <em>Underscore</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-HexDigitOrSeparator" class="grammar-tule">
<dl>
<dt><strong><em>HexDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>HexDigit</em> | <em>Underscore</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-BinDigitOrSeparator" class="grammar-tule">
<dl>
<dt><strong><em>BinDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>BinDigit</em> | <em>Underscore</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-DecDigits" class="grammar-tule">
<dl>
<dt><strong><em>DecDigits</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-BooleanLiteral" class="grammar-tule">
<dl>
<dt><strong><em>BooleanLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'true'</code> | <code>'false'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-NullLiteral" class="grammar-tule">
<dl>
<dt><strong><em>NullLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'null'</code></span>
</dd>
</dl>
</div>
<h5 id="identifiers">Identifiers</h5>
<div id="grammar-rule-Identifier" class="grammar-tule">
<dl>
<dt><strong><em>Identifier</em>:</strong></dt>
<dd><span class="sentence">(<em>Letter</em> | <em>Underscore</em>) {<em>Letter</em> | <em>Underscore</em> | <em>UnicodeDigit</em>}<br />
| <code>'`'</code> {<em>EscapedIdentifierCharacter</em>} <code>'`'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-EscapedIdentifierCharacter" class="grammar-tule">
<dl>
<dt><strong><em>EscapedIdentifierCharacter</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;any character except CR, LF, <code>'`''</code>, <code>'['</code>, <code>']'</code>, <code>'&lt;'</code> or <code>'&gt;'</code>&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-IdentifierOrSoftKey" class="grammar-tule">
<dl>
<dt><strong><em>IdentifierOrSoftKey</em>:</strong></dt>
<dd><span class="sentence"><em>Identifier</em> | <em>SoftKeyword</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-AtIdentifier" class="grammar-tule">
<dl>
<dt><strong><em>AtIdentifier</em>:</strong></dt>
<dd><span class="sentence"><code>'@'</code> <em>IdentifierOrSoftKey</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-IdentifierAt" class="grammar-tule">
<dl>
<dt><strong><em>IdentifierAt</em>:</strong></dt>
<dd><span class="sentence"><em>IdentifierOrSoftKey</em> <code>'@'</code></span>
</dd>
</dl>
</div>
<h5 id="string-literals">String literals</h5>
<div class="paragraph">
<p><span class="sentence">Syntax literals are fully defined in syntax grammar due to the complex nature of string interpolation</span></p>
</div>
<div id="grammar-rule-CharacterLiteral" class="grammar-tule">
<dl>
<dt><strong><em>CharacterLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'''</code> (<em>EscapeSeq</em> | <em>&lt;any character except CR, LF, <code>'''</code> and <code>'\'</code>&gt;</em>) <code>'''</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-EscapeSeq" class="grammar-tule">
<dl>
<dt><strong><em>EscapeSeq</em>:</strong></dt>
<dd><span class="sentence"><em>UnicodeCharacterLiteral</em> | <em>EscapedCharacter</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-UnicodeCharacterLiteral" class="grammar-tule">
<dl>
<dt><strong><em>UnicodeCharacterLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'\'</code> <code>'u'</code> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-EscapedCharacter" class="grammar-tule">
<dl>
<dt><strong><em>EscapedCharacter</em>:</strong></dt>
<dd><span class="sentence"><code>'\'</code> (<code>'t'</code> | <code>'b'</code> | <code>'r'</code> | <code>'n'</code> | <code>'</code> | <code>'&quot;'</code> | <code>'\'</code> | <code>'$'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-FieldIdentifier" class="grammar-tule">
<dl>
<dt><strong><em>FieldIdentifier</em>:</strong></dt>
<dd><span class="sentence"><code>'$'</code> <em>IdentifierOrSoftKey</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-LineStrRef" class="grammar-tule">
<dl>
<dt><strong><em>LineStrRef</em>:</strong></dt>
<dd><span class="sentence"><em>FieldIdentifier</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-LineStrEscapedChar" class="grammar-tule">
<dl>
<dt><strong><em>LineStrEscapedChar</em>:</strong></dt>
<dd><span class="sentence"><em>EscapedCharacter</em> | <em>UnicodeCharacterLiteral</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-LineStrExprStart" class="grammar-tule">
<dl>
<dt><strong><em>LineStrExprStart</em>:</strong></dt>
<dd><span class="sentence"><code>'${'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-MultiLineStringQuote" class="grammar-tule">
<dl>
<dt><strong><em>MultiLineStringQuote</em>:</strong></dt>
<dd><span class="sentence"><code>'&quot;'</code> {<code>'&quot;'</code>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-MultiLineStrRef" class="grammar-tule">
<dl>
<dt><strong><em>MultiLineStrRef</em>:</strong></dt>
<dd><span class="sentence"><em>FieldIdentifier</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-MultiLineStrText" class="grammar-tule">
<dl>
<dt><strong><em>MultiLineStrText</em>:</strong></dt>
<dd><span class="sentence">{&lt;any character except <code>'&quot;'</code> and <code>'$'</code>} | <code>'$'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-MultiLineStrExprStart" class="grammar-tule">
<dl>
<dt><strong><em>MultiLineStrExprStart</em>:</strong></dt>
<dd><span class="sentence"><code>'${'</code></span>
</dd>
</dl>
</div>
<h5 id="misc">Misc</h5>
<div id="grammar-rule-EOF" class="grammar-tule">
<dl>
<dt><strong><em>EOF</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;end of input&gt;</em></span>
</dd>
</dl>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: redo all the lexical grammar, right now it is a hand-written mess</span></p>
</div>
</div>
<h4 id="syntax-grammar">Syntax grammar</h4>
<div id="grammar-rule-kotlinFile" class="grammar-rule">
<dl>
<dt><strong><em>kotlinFile</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-shebangLine">shebangLine</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
{<em><a href="#grammar-rule-fileAnnotation">fileAnnotation</a></em>}<br />
[<em><a href="#grammar-rule-packageHeader">packageHeader</a></em>]<br />
<em><a href="#grammar-rule-importList">importList</a></em><br />
{<em><a href="#grammar-rule-topLevelObject">topLevelObject</a></em>}<br />
<em><a href="#grammar-rule-EOF">EOF</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-script" class="grammar-rule">
<dl>
<dt><strong><em>script</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-shebangLine">shebangLine</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
{<em><a href="#grammar-rule-fileAnnotation">fileAnnotation</a></em>}<br />
[<em><a href="#grammar-rule-packageHeader">packageHeader</a></em>]<br />
<em><a href="#grammar-rule-importList">importList</a></em><br />
{<em><a href="#grammar-rule-statement">statement</a></em> <em><a href="#grammar-rule-semi">semi</a></em>}<br />
<em><a href="#grammar-rule-EOF">EOF</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-fileAnnotation" class="grammar-rule">
<dl>
<dt><strong><em>fileAnnotation</em>:</strong></dt>
<dd><span class="sentence"><code>'@file'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>':'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
((<code>'['</code> (<em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em> {<em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em>}) <code>']'</code>) | <em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em>)<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-packageHeader" class="grammar-rule">
<dl>
<dt><strong><em>packageHeader</em>:</strong></dt>
<dd><span class="sentence"><code>'package'</code> <em><a href="#grammar-rule-identifier">identifier</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-importList" class="grammar-rule">
<dl>
<dt><strong><em>importList</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-importHeader">importHeader</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-importHeader" class="grammar-rule">
<dl>
<dt><strong><em>importHeader</em>:</strong></dt>
<dd><span class="sentence"><code>'import'</code> <em><a href="#grammar-rule-identifier">identifier</a></em> [(<code>'.'</code> <code>'*'</code>) | <em><a href="#grammar-rule-importAlias">importAlias</a></em>] [<em><a href="#grammar-rule-semi">semi</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-importAlias" class="grammar-rule">
<dl>
<dt><strong><em>importAlias</em>:</strong></dt>
<dd><span class="sentence"><code>'as'</code> <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-topLevelObject" class="grammar-rule">
<dl>
<dt><strong><em>topLevelObject</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-declaration">declaration</a></em> [<em><a href="#grammar-rule-semis">semis</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-classDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>classDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
(<code>'class'</code> | <code>'interface'</code>)<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-primaryConstructor">primaryConstructor</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>) | ({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-enumClassBody">enumClassBody</a></em>)]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-primaryConstructor" class="grammar-rule">
<dl>
<dt><strong><em>primaryConstructor</em>:</strong></dt>
<dd><span class="sentence">[[<em><a href="#grammar-rule-modifiers">modifiers</a></em>] <code>'constructor'</code> {<em><a href="#grammar-rule-NL">NL</a></em>}] <em><a href="#grammar-rule-classParameters">classParameters</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-classParameters" class="grammar-rule">
<dl>
<dt><strong><em>classParameters</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-classParameter">classParameter</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classParameter">classParameter</a></em>}]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-classParameter" class="grammar-rule">
<dl>
<dt><strong><em>classParameter</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
[<code>'val'</code> | <code>'var'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
<code>':'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-delegationSpecifiers" class="grammar-rule">
<dl>
<dt><strong><em>delegationSpecifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-annotatedDelegationSpecifier">annotatedDelegationSpecifier</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-annotatedDelegationSpecifier">annotatedDelegationSpecifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-annotatedDelegationSpecifier" class="grammar-rule">
<dl>
<dt><strong><em>annotatedDelegationSpecifier</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-annotation">annotation</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifier">delegationSpecifier</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-delegationSpecifier" class="grammar-rule">
<dl>
<dt><strong><em>delegationSpecifier</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-constructorInvocation">constructorInvocation</a></em><br />
| <em><a href="#grammar-rule-explicitDelegation">explicitDelegation</a></em><br />
| <em><a href="#grammar-rule-userType">userType</a></em><br />
| <em><a href="#grammar-rule-functionType">functionType</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-constructorInvocation" class="grammar-rule">
<dl>
<dt><strong><em>constructorInvocation</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-userType">userType</a></em> <em><a href="#grammar-rule-valueArguments">valueArguments</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-explicitDelegation" class="grammar-rule">
<dl>
<dt><strong><em>explicitDelegation</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-userType">userType</a></em> | <em><a href="#grammar-rule-functionType">functionType</a></em>)<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'by'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-classBody" class="grammar-rule">
<dl>
<dt><strong><em>classBody</em>:</strong></dt>
<dd><span class="sentence"><code>'{'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-classMemberDeclarations">classMemberDeclarations</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-classMemberDeclarations" class="grammar-rule">
<dl>
<dt><strong><em>classMemberDeclarations</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-classMemberDeclaration">classMemberDeclaration</a></em> [<em><a href="#grammar-rule-semis">semis</a></em>]}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-classMemberDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>classMemberDeclaration</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-declaration">declaration</a></em><br />
| <em><a href="#grammar-rule-companionObject">companionObject</a></em><br />
| <em><a href="#grammar-rule-anonymousInitializer">anonymousInitializer</a></em><br />
| <em><a href="#grammar-rule-secondaryConstructor">secondaryConstructor</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-anonymousInitializer" class="grammar-rule">
<dl>
<dt><strong><em>anonymousInitializer</em>:</strong></dt>
<dd><span class="sentence"><code>'init'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-secondaryConstructor" class="grammar-rule">
<dl>
<dt><strong><em>secondaryConstructor</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'constructor'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-functionValueParameters">functionValueParameters</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-constructorDelegationCall">constructorDelegationCall</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-block">block</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-constructorDelegationCall" class="grammar-rule">
<dl>
<dt><strong><em>constructorDelegationCall</em>:</strong></dt>
<dd><span class="sentence">(<code>'this'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArguments">valueArguments</a></em>)<br />
| (<code>'super'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArguments">valueArguments</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-enumClassBody" class="grammar-rule">
<dl>
<dt><strong><em>enumClassBody</em>:</strong></dt>
<dd><span class="sentence"><code>'{'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-enumEntries">enumEntries</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>';'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-classMemberDeclarations">classMemberDeclarations</a></em>]]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-enumEntries" class="grammar-rule">
<dl>
<dt><strong><em>enumEntries</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-enumEntry">enumEntry</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-enumEntry">enumEntry</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} [<code>','</code>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-enumEntry" class="grammar-rule">
<dl>
<dt><strong><em>enumEntry</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>}] <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArguments">valueArguments</a></em>] [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>functionDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<em><a href="#grammar-rule-functionHeader">functionHeader</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-functionValueParameters">functionValueParameters</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionBody">functionBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionHeader" class="grammar-rule">
<dl>
<dt><strong><em>functionHeader</em>:</strong></dt>
<dd><span class="sentence"><code>'fun'</code><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-receiverType">receiverType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionValueParameters" class="grammar-rule">
<dl>
<dt><strong><em>functionValueParameters</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-functionValueParameter">functionValueParameter</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionValueParameter">functionValueParameter</a></em>}]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionValueParameter" class="grammar-rule">
<dl>
<dt><strong><em>functionValueParameter</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>] <em><a href="#grammar-rule-parameter">parameter</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-parameter" class="grammar-rule">
<dl>
<dt><strong><em>parameter</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>':'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-setterParameter" class="grammar-rule">
<dl>
<dt><strong><em>setterParameter</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} [<code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionBody" class="grammar-rule">
<dl>
<dt><strong><em>functionBody</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-block">block</a></em><br />
| (<code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-objectDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>objectDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'object'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-companionObject" class="grammar-rule">
<dl>
<dt><strong><em>companionObject</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'companion'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'object'</code><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-propertyDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>propertyDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
(<code>'val'</code> | <code>'var'</code>)<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-receiverType">receiverType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
({<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em> | <em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em>))<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} ((<code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>) | <em><a href="#grammar-rule-propertyDelegate">propertyDelegate</a></em>)]<br />
[(<em><a href="#grammar-rule-NL">NL</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>}) <code>';'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
(([<em><a href="#grammar-rule-getter">getter</a></em>] [{<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-semi">semi</a></em>] <em><a href="#grammar-rule-setter">setter</a></em>]) | ([<em><a href="#grammar-rule-setter">setter</a></em>] [{<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-semi">semi</a></em>] <em><a href="#grammar-rule-getter">getter</a></em>]))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiVariableDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>multiVariableDeclaration</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-variableDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>variableDeclaration</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-annotation">annotation</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-propertyDelegate" class="grammar-rule">
<dl>
<dt><strong><em>propertyDelegate</em>:</strong></dt>
<dd><span class="sentence"><code>'by'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-getter" class="grammar-rule">
<dl>
<dt><strong><em>getter</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-modifiers">modifiers</a></em>] <code>'get'</code>)<br />
| ([<em><a href="#grammar-rule-modifiers">modifiers</a></em>] <code>'get'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionBody">functionBody</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-setter" class="grammar-rule">
<dl>
<dt><strong><em>setter</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-modifiers">modifiers</a></em>] <code>'set'</code>)<br />
| ([<em><a href="#grammar-rule-modifiers">modifiers</a></em>] <code>'set'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-annotation">annotation</a></em> | <em><a href="#grammar-rule-parameterModifier">parameterModifier</a></em>} <em><a href="#grammar-rule-setterParameter">setterParameter</a></em> <code>')'</code> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionBody">functionBody</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeAlias" class="grammar-rule">
<dl>
<dt><strong><em>typeAlias</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'typealias'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'='</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeParameters" class="grammar-rule">
<dl>
<dt><strong><em>typeParameters</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-typeParameter">typeParameter</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameter">typeParameter</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'&gt;'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeParameter" class="grammar-rule">
<dl>
<dt><strong><em>typeParameter</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-typeParameterModifiers">typeParameterModifiers</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeParameterModifiers" class="grammar-rule">
<dl>
<dt><strong><em>typeParameterModifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-typeParameterModifier">typeParameterModifier</a></em> {<em><a href="#grammar-rule-typeParameterModifier">typeParameterModifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeParameterModifier" class="grammar-rule">
<dl>
<dt><strong><em>typeParameterModifier</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-reificationModifier">reificationModifier</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>})<br />
| (<em><a href="#grammar-rule-varianceModifier">varianceModifier</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>})<br />
| <em><a href="#grammar-rule-annotation">annotation</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-type" class="grammar-rule">
<dl>
<dt><strong><em>type</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-typeModifiers">typeModifiers</a></em>] (<em><a href="#grammar-rule-parenthesizedType">parenthesizedType</a></em> | <em><a href="#grammar-rule-nullableType">nullableType</a></em> | <em><a href="#grammar-rule-typeReference">typeReference</a></em> | <em><a href="#grammar-rule-functionType">functionType</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeModifiers" class="grammar-rule">
<dl>
<dt><strong><em>typeModifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-typeModifier">typeModifier</a></em> {<em><a href="#grammar-rule-typeModifier">typeModifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeModifier" class="grammar-rule">
<dl>
<dt><strong><em>typeModifier</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-annotation">annotation</a></em><br />
| (<code>'suspend'</code> {<em><a href="#grammar-rule-NL">NL</a></em>})</span>
</dd>
</dl>
</div>
<div id="grammar-rule-parenthesizedType" class="grammar-rule">
<dl>
<dt><strong><em>parenthesizedType</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-nullableType" class="grammar-rule">
<dl>
<dt><strong><em>nullableType</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-typeReference">typeReference</a></em> | <em><a href="#grammar-rule-parenthesizedType">parenthesizedType</a></em>) {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-quest">quest</a></em> {<em><a href="#grammar-rule-quest">quest</a></em>})</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeReference" class="grammar-rule">
<dl>
<dt><strong><em>typeReference</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-userType">userType</a></em><br />
| <code>'dynamic'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionType" class="grammar-rule">
<dl>
<dt><strong><em>functionType</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-receiverType">receiverType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code> {<em><a href="#grammar-rule-NL">NL</a></em>}]<br />
<em><a href="#grammar-rule-functionTypeParameters">functionTypeParameters</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'-&gt;'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-receiverType" class="grammar-rule">
<dl>
<dt><strong><em>receiverType</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-typeModifiers">typeModifiers</a></em>] (<em><a href="#grammar-rule-parenthesizedType">parenthesizedType</a></em> | <em><a href="#grammar-rule-nullableType">nullableType</a></em> | <em><a href="#grammar-rule-typeReference">typeReference</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-userType" class="grammar-rule">
<dl>
<dt><strong><em>userType</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-simpleUserType">simpleUserType</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-simpleUserType">simpleUserType</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-parenthesizedUserType" class="grammar-rule">
<dl>
<dt><strong><em>parenthesizedUserType</em>:</strong></dt>
<dd><span class="sentence">(<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-userType">userType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)<br />
| (<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-parenthesizedUserType">parenthesizedUserType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-simpleUserType" class="grammar-rule">
<dl>
<dt><strong><em>simpleUserType</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeArguments">typeArguments</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionTypeParameters" class="grammar-rule">
<dl>
<dt><strong><em>functionTypeParameters</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-parameter">parameter</a></em> | <em><a href="#grammar-rule-type">type</a></em>]<br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-parameter">parameter</a></em> | <em><a href="#grammar-rule-type">type</a></em>)}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeConstraints" class="grammar-rule">
<dl>
<dt><strong><em>typeConstraints</em>:</strong></dt>
<dd><span class="sentence"><code>'where'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraint">typeConstraint</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraint">typeConstraint</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeConstraint" class="grammar-rule">
<dl>
<dt><strong><em>typeConstraint</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-annotation">annotation</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>':'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-block" class="grammar-rule">
<dl>
<dt><strong><em>block</em>:</strong></dt>
<dd><span class="sentence"><code>'{'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-statements">statements</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-statements" class="grammar-rule">
<dl>
<dt><strong><em>statements</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-statement">statement</a></em> {<em><a href="#grammar-rule-semis">semis</a></em> <em><a href="#grammar-rule-statement">statement</a></em>} [<em><a href="#grammar-rule-semis">semis</a></em>]]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-statement" class="grammar-rule">
<dl>
<dt><strong><em>statement</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-label">label</a></em> | <em><a href="#grammar-rule-annotation">annotation</a></em>} (<em><a href="#grammar-rule-declaration">declaration</a></em> | <em><a href="#grammar-rule-assignment">assignment</a></em> | <em><a href="#grammar-rule-loopStatement">loopStatement</a></em> | <em><a href="#grammar-rule-expression">expression</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-declaration" class="grammar-rule">
<dl>
<dt><strong><em>declaration</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-classDeclaration">classDeclaration</a></em><br />
| <em><a href="#grammar-rule-objectDeclaration">objectDeclaration</a></em><br />
| <em><a href="#grammar-rule-functionDeclaration">functionDeclaration</a></em><br />
| <em><a href="#grammar-rule-propertyDeclaration">propertyDeclaration</a></em><br />
| <em><a href="#grammar-rule-typeAlias">typeAlias</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-assignment" class="grammar-rule">
<dl>
<dt><strong><em>assignment</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-directlyAssignableExpression">directlyAssignableExpression</a></em> <code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)<br />
| (<em><a href="#grammar-rule-assignableExpression">assignableExpression</a></em> <em><a href="#grammar-rule-assignmentAndOperator">assignmentAndOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-expression" class="grammar-rule">
<dl>
<dt><strong><em>expression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-disjunction">disjunction</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-disjunction" class="grammar-rule">
<dl>
<dt><strong><em>disjunction</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-conjunction">conjunction</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'||'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-conjunction">conjunction</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-conjunction" class="grammar-rule">
<dl>
<dt><strong><em>conjunction</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-equality">equality</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'&amp;&amp;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-equality">equality</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-equality" class="grammar-rule">
<dl>
<dt><strong><em>equality</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-comparison">comparison</a></em> {<em><a href="#grammar-rule-equalityOperator">equalityOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-comparison">comparison</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-comparison" class="grammar-rule">
<dl>
<dt><strong><em>comparison</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-infixOperation">infixOperation</a></em> [<em><a href="#grammar-rule-comparisonOperator">comparisonOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-infixOperation">infixOperation</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-infixOperation" class="grammar-rule">
<dl>
<dt><strong><em>infixOperation</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-elvisExpression">elvisExpression</a></em> {(<em><a href="#grammar-rule-inOperator">inOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-elvisExpression">elvisExpression</a></em>) | (<em><a href="#grammar-rule-isOperator">isOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>)}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-elvisExpression" class="grammar-rule">
<dl>
<dt><strong><em>elvisExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-infixFunctionCall">infixFunctionCall</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-elvis">elvis</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-infixFunctionCall">infixFunctionCall</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-infixFunctionCall" class="grammar-rule">
<dl>
<dt><strong><em>infixFunctionCall</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-rangeExpression">rangeExpression</a></em> {<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-rangeExpression">rangeExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-rangeExpression" class="grammar-rule">
<dl>
<dt><strong><em>rangeExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-additiveExpression">additiveExpression</a></em> {<code>'..'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-additiveExpression">additiveExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-additiveExpression" class="grammar-rule">
<dl>
<dt><strong><em>additiveExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-multiplicativeExpression">multiplicativeExpression</a></em> {<em><a href="#grammar-rule-additiveOperator">additiveOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-multiplicativeExpression">multiplicativeExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiplicativeExpression" class="grammar-rule">
<dl>
<dt><strong><em>multiplicativeExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-asExpression">asExpression</a></em> {<em><a href="#grammar-rule-multiplicativeOperator">multiplicativeOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-asExpression">asExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-asExpression" class="grammar-rule">
<dl>
<dt><strong><em>asExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-prefixUnaryExpression">prefixUnaryExpression</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-asOperator">asOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-prefixUnaryExpression" class="grammar-rule">
<dl>
<dt><strong><em>prefixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-unaryPrefix">unaryPrefix</a></em>} <em><a href="#grammar-rule-postfixUnaryExpression">postfixUnaryExpression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-unaryPrefix" class="grammar-rule">
<dl>
<dt><strong><em>unaryPrefix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-annotation">annotation</a></em><br />
| <em><a href="#grammar-rule-label">label</a></em><br />
| (<em><a href="#grammar-rule-prefixUnaryOperator">prefixUnaryOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>})</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnaryExpression" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em><br />
| (<em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em> (<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em> {<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em>}))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnarySuffix" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-postfixUnaryOperator">postfixUnaryOperator</a></em><br />
| <em><a href="#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="#grammar-rule-callSuffix">callSuffix</a></em><br />
| <em><a href="#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-directlyAssignableExpression" class="grammar-rule">
<dl>
<dt><strong><em>directlyAssignableExpression</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-postfixUnaryExpression">postfixUnaryExpression</a></em> <em><a href="#grammar-rule-assignableSuffix">assignableSuffix</a></em>)<br />
| <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-assignableExpression" class="grammar-rule">
<dl>
<dt><strong><em>assignableExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-prefixUnaryExpression">prefixUnaryExpression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-assignableSuffix" class="grammar-rule">
<dl>
<dt><strong><em>assignableSuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-indexingSuffix" class="grammar-rule">
<dl>
<dt><strong><em>indexingSuffix</em>:</strong></dt>
<dd><span class="sentence"><code>'['</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>']'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-navigationSuffix" class="grammar-rule">
<dl>
<dt><strong><em>navigationSuffix</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-memberAccessOperator">memberAccessOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> | <em><a href="#grammar-rule-parenthesizedExpression">parenthesizedExpression</a></em> | <code>'class'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-callSuffix" class="grammar-rule">
<dl>
<dt><strong><em>callSuffix</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-typeArguments">typeArguments</a></em>] [<em><a href="#grammar-rule-valueArguments">valueArguments</a></em>] <em><a href="#grammar-rule-annotatedLambda">annotatedLambda</a></em>)<br />
| ([<em><a href="#grammar-rule-typeArguments">typeArguments</a></em>] <em><a href="#grammar-rule-valueArguments">valueArguments</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-annotatedLambda" class="grammar-rule">
<dl>
<dt><strong><em>annotatedLambda</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-annotation">annotation</a></em>} [<em><a href="#grammar-rule-label">label</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-lambdaLiteral">lambdaLiteral</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-valueArguments" class="grammar-rule">
<dl>
<dt><strong><em>valueArguments</em>:</strong></dt>
<dd><span class="sentence">(<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)<br />
| (<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArgument">valueArgument</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArgument">valueArgument</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeArguments" class="grammar-rule">
<dl>
<dt><strong><em>typeArguments</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-typeProjection">typeProjection</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeProjection">typeProjection</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'&gt;'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjection" class="grammar-rule">
<dl>
<dt><strong><em>typeProjection</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-typeProjectionModifiers">typeProjectionModifiers</a></em>] <em><a href="#grammar-rule-type">type</a></em>)<br />
| <code>'*'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjectionModifiers" class="grammar-rule">
<dl>
<dt><strong><em>typeProjectionModifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-typeProjectionModifier">typeProjectionModifier</a></em> {<em><a href="#grammar-rule-typeProjectionModifier">typeProjectionModifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjectionModifier" class="grammar-rule">
<dl>
<dt><strong><em>typeProjectionModifier</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-varianceModifier">varianceModifier</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>})<br />
| <em><a href="#grammar-rule-annotation">annotation</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-valueArgument" class="grammar-rule">
<dl>
<dt><strong><em>valueArgument</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-annotation">annotation</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>}]<br />
[<code>'*'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-primaryExpression" class="grammar-rule">
<dl>
<dt><strong><em>primaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-parenthesizedExpression">parenthesizedExpression</a></em><br />
| <em><a href="#grammar-rule-literalConstant">literalConstant</a></em><br />
| <em><a href="#grammar-rule-stringLiteral">stringLiteral</a></em><br />
| <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
| <em><a href="#grammar-rule-callableReference">callableReference</a></em><br />
| <em><a href="#grammar-rule-functionLiteral">functionLiteral</a></em><br />
| <em><a href="#grammar-rule-objectLiteral">objectLiteral</a></em><br />
| <em><a href="#grammar-rule-collectionLiteral">collectionLiteral</a></em><br />
| <em><a href="#grammar-rule-thisExpression">thisExpression</a></em><br />
| <em><a href="#grammar-rule-superExpression">superExpression</a></em><br />
| <em><a href="#grammar-rule-ifExpression">ifExpression</a></em><br />
| <em><a href="#grammar-rule-whenExpression">whenExpression</a></em><br />
| <em><a href="#grammar-rule-tryExpression">tryExpression</a></em><br />
| <em><a href="#grammar-rule-jumpExpression">jumpExpression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-parenthesizedExpression" class="grammar-rule">
<dl>
<dt><strong><em>parenthesizedExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-collectionLiteral" class="grammar-rule">
<dl>
<dt><strong><em>collectionLiteral</em>:</strong></dt>
<dd><span class="sentence">(<code>'['</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <code>']'</code>)<br />
| (<code>'['</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>']'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-literalConstant" class="grammar-rule">
<dl>
<dt><strong><em>literalConstant</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-BooleanLiteral">BooleanLiteral</a></em><br />
| <em><a href="#grammar-rule-IntegerLiteral">IntegerLiteral</a></em><br />
| <em><a href="#grammar-rule-HexLiteral">HexLiteral</a></em><br />
| <em><a href="#grammar-rule-BinLiteral">BinLiteral</a></em><br />
| <em><a href="#grammar-rule-CharacterLiteral">CharacterLiteral</a></em><br />
| <em><a href="#grammar-rule-RealLiteral">RealLiteral</a></em><br />
| <em><a href="#grammar-rule-NullLiteral">NullLiteral</a></em><br />
| <em><a href="#grammar-rule-LongLiteral">LongLiteral</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-stringLiteral" class="grammar-rule">
<dl>
<dt><strong><em>stringLiteral</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-lineStringLiteral">lineStringLiteral</a></em><br />
| <em><a href="#grammar-rule-multiLineStringLiteral">multiLineStringLiteral</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-lineStringLiteral" class="grammar-rule">
<dl>
<dt><strong><em>lineStringLiteral</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-QUOTE_OPEN">QUOTE_OPEN</a></em> {<em><a href="#grammar-rule-lineStringContent">lineStringContent</a></em> | <em><a href="#grammar-rule-lineStringExpression">lineStringExpression</a></em>} <em><a href="#grammar-rule-QUOTE_CLOSE">QUOTE_CLOSE</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiLineStringLiteral" class="grammar-rule">
<dl>
<dt><strong><em>multiLineStringLiteral</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-TRIPLE_QUOTE_OPEN">TRIPLE_QUOTE_OPEN</a></em> {<em><a href="#grammar-rule-multiLineStringContent">multiLineStringContent</a></em> | <em><a href="#grammar-rule-multiLineStringExpression">multiLineStringExpression</a></em> | <em><a href="#grammar-rule-MultiLineStringQuote">MultiLineStringQuote</a></em>} <em><a href="#grammar-rule-TRIPLE_QUOTE_CLOSE">TRIPLE_QUOTE_CLOSE</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-lineStringContent" class="grammar-rule">
<dl>
<dt><strong><em>lineStringContent</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-LineStrText">LineStrText</a></em><br />
| <em><a href="#grammar-rule-LineStrEscapedChar">LineStrEscapedChar</a></em><br />
| <em><a href="#grammar-rule-LineStrRef">LineStrRef</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-lineStringExpression" class="grammar-rule">
<dl>
<dt><strong><em>lineStringExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-LineStrExprStart">LineStrExprStart</a></em> <em><a href="#grammar-rule-expression">expression</a></em> <code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiLineStringContent" class="grammar-rule">
<dl>
<dt><strong><em>multiLineStringContent</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-MultiLineStrText">MultiLineStrText</a></em><br />
| <em><a href="#grammar-rule-MultiLineStringQuote">MultiLineStringQuote</a></em><br />
| <em><a href="#grammar-rule-MultiLineStrRef">MultiLineStrRef</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiLineStringExpression" class="grammar-rule">
<dl>
<dt><strong><em>multiLineStringExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-MultiLineStrExprStart">MultiLineStrExprStart</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaLiteral" class="grammar-rule">
<dl>
<dt><strong><em>lambdaLiteral</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-LCURL">LCURL</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-statements">statements</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-RCURL">RCURL</a></em>)<br />
| (<em><a href="#grammar-rule-LCURL">LCURL</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-lambdaParameters">lambdaParameters</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-ARROW">ARROW</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-statements">statements</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'}'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaParameters" class="grammar-rule">
<dl>
<dt><strong><em>lambdaParameters</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-lambdaParameter">lambdaParameter</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-COMMA">COMMA</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-lambdaParameter">lambdaParameter</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaParameter" class="grammar-rule">
<dl>
<dt><strong><em>lambdaParameter</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em><br />
| (<em><a href="#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-COLON">COLON</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>])</span>
</dd>
</dl>
</div>
<div id="grammar-rule-anonymousFunction" class="grammar-rule">
<dl>
<dt><strong><em>anonymousFunction</em>:</strong></dt>
<dd><span class="sentence"><code>'fun'</code><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-functionValueParameters">functionValueParameters</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionBody">functionBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionLiteral" class="grammar-rule">
<dl>
<dt><strong><em>functionLiteral</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-lambdaLiteral">lambdaLiteral</a></em><br />
| <em><a href="#grammar-rule-anonymousFunction">anonymousFunction</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-objectLiteral" class="grammar-rule">
<dl>
<dt><strong><em>objectLiteral</em>:</strong></dt>
<dd><span class="sentence">(<code>'object'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>])<br />
| (<code>'object'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-thisExpression" class="grammar-rule">
<dl>
<dt><strong><em>thisExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'this'</code><br />
| <em><a href="#grammar-rule-THIS_AT">THIS_AT</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-superExpression" class="grammar-rule">
<dl>
<dt><strong><em>superExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'super'</code> [<code>'&lt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'&gt;'</code>] [<code>'@'</code> <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em>])<br />
| <em><a href="#grammar-rule-SUPER_AT">SUPER_AT</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-controlStructureBody" class="grammar-rule">
<dl>
<dt><strong><em>controlStructureBody</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-block">block</a></em><br />
| <em><a href="#grammar-rule-statement">statement</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-ifExpression" class="grammar-rule">
<dl>
<dt><strong><em>ifExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'if'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> [[<code>';'</code>] {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'else'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>])<br />
| (<code>'if'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} [<code>';'</code> {<em><a href="#grammar-rule-NL">NL</a></em>}] <code>'else'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenExpression" class="grammar-rule">
<dl>
<dt><strong><em>whenExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'when'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<code>'('</code> <em><a href="#grammar-rule-expression">expression</a></em> <code>')'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'{'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
{<em><a href="#grammar-rule-whenEntry">whenEntry</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>}}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenEntry" class="grammar-rule">
<dl>
<dt><strong><em>whenEntry</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-whenCondition">whenCondition</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-whenCondition">whenCondition</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>])<br />
| (<code>'else'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>])</span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenCondition" class="grammar-rule">
<dl>
<dt><strong><em>whenCondition</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-expression">expression</a></em><br />
| <em><a href="#grammar-rule-rangeTest">rangeTest</a></em><br />
| <em><a href="#grammar-rule-typeTest">typeTest</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-rangeTest" class="grammar-rule">
<dl>
<dt><strong><em>rangeTest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-inOperator">inOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeTest" class="grammar-rule">
<dl>
<dt><strong><em>typeTest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-isOperator">isOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-tryExpression" class="grammar-rule">
<dl>
<dt><strong><em>tryExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'try'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-block">block</a></em> ((({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-catchBlock">catchBlock</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-catchBlock">catchBlock</a></em>}) [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-finallyBlock">finallyBlock</a></em>]) | ({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-finallyBlock">finallyBlock</a></em>))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-catchBlock" class="grammar-rule">
<dl>
<dt><strong><em>catchBlock</em>:</strong></dt>
<dd><span class="sentence"><code>'catch'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'('</code><br />
{<em><a href="#grammar-rule-annotation">annotation</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
<code>':'</code><br />
<em><a href="#grammar-rule-userType">userType</a></em><br />
<code>')'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-finallyBlock" class="grammar-rule">
<dl>
<dt><strong><em>finallyBlock</em>:</strong></dt>
<dd><span class="sentence"><code>'finally'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-loopStatement" class="grammar-rule">
<dl>
<dt><strong><em>loopStatement</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-forStatement">forStatement</a></em><br />
| <em><a href="#grammar-rule-whileStatement">whileStatement</a></em><br />
| <em><a href="#grammar-rule-doWhileStatement">doWhileStatement</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-forStatement" class="grammar-rule">
<dl>
<dt><strong><em>forStatement</em>:</strong></dt>
<dd><span class="sentence"><code>'for'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'('</code><br />
{<em><a href="#grammar-rule-annotation">annotation</a></em>}<br />
(<em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em> | <em><a href="#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em>)<br />
<code>'in'</code><br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
<code>')'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-whileStatement" class="grammar-rule">
<dl>
<dt><strong><em>whileStatement</em>:</strong></dt>
<dd><span class="sentence">(<code>'while'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> <em><a href="#grammar-rule-expression">expression</a></em> <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>)<br />
| (<code>'while'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> <em><a href="#grammar-rule-expression">expression</a></em> <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>';'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-doWhileStatement" class="grammar-rule">
<dl>
<dt><strong><em>doWhileStatement</em>:</strong></dt>
<dd><span class="sentence"><code>'do'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'while'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'('</code><br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-jumpExpression" class="grammar-rule">
<dl>
<dt><strong><em>jumpExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'throw'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)<br />
| ((<code>'return'</code> | <em><a href="#grammar-rule-RETURN_AT">RETURN_AT</a></em>) [<em><a href="#grammar-rule-expression">expression</a></em>])<br />
| <code>'continue'</code><br />
| <em><a href="#grammar-rule-CONTINUE_AT">CONTINUE_AT</a></em><br />
| <code>'break'</code><br />
| <em><a href="#grammar-rule-BREAK_AT">BREAK_AT</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-callableReference" class="grammar-rule">
<dl>
<dt><strong><em>callableReference</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-receiverType">receiverType</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'::'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
(<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> | <code>'class'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-assignmentAndOperator" class="grammar-rule">
<dl>
<dt><strong><em>assignmentAndOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'+='</code><br />
| <code>'-='</code><br />
| <code>'*='</code><br />
| <code>'/='</code><br />
| <code>'%='</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-equalityOperator" class="grammar-rule">
<dl>
<dt><strong><em>equalityOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'!='</code><br />
| <code>'!=='</code><br />
| <code>'=='</code><br />
| <code>'==='</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-comparisonOperator" class="grammar-rule">
<dl>
<dt><strong><em>comparisonOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
| <code>'&gt;'</code><br />
| <code>'&lt;='</code><br />
| <code>'&gt;='</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-inOperator" class="grammar-rule">
<dl>
<dt><strong><em>inOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'in'</code><br />
| <em><a href="#grammar-rule-NOT_IN">NOT_IN</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-isOperator" class="grammar-rule">
<dl>
<dt><strong><em>isOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'is'</code><br />
| <em><a href="#grammar-rule-NOT_IS">NOT_IS</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-additiveOperator" class="grammar-rule">
<dl>
<dt><strong><em>additiveOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'+'</code><br />
| <code>'-'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiplicativeOperator" class="grammar-rule">
<dl>
<dt><strong><em>multiplicativeOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'*'</code><br />
| <code>'/'</code><br />
| <code>'%'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-asOperator" class="grammar-rule">
<dl>
<dt><strong><em>asOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'as'</code><br />
| <code>'as?'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-prefixUnaryOperator" class="grammar-rule">
<dl>
<dt><strong><em>prefixUnaryOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'++'</code><br />
| <code>'--'</code><br />
| <code>'-'</code><br />
| <code>'+'</code><br />
| <em><a href="#grammar-rule-excl">excl</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnaryOperator" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'++'</code><br />
| <code>'--'</code><br />
| (<em><a href="#grammar-rule-EXCL_NO_WS">EXCL_NO_WS</a></em> <em><a href="#grammar-rule-excl">excl</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-memberAccessOperator" class="grammar-rule">
<dl>
<dt><strong><em>memberAccessOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'.'</code><br />
| <em><a href="#grammar-rule-safeNav">safeNav</a></em><br />
| <code>'::'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-modifiers" class="grammar-rule">
<dl>
<dt><strong><em>modifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-annotation">annotation</a></em> | <em><a href="#grammar-rule-modifier">modifier</a></em> {<em><a href="#grammar-rule-annotation">annotation</a></em> | <em><a href="#grammar-rule-modifier">modifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-modifier" class="grammar-rule">
<dl>
<dt><strong><em>modifier</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-classModifier">classModifier</a></em> | <em><a href="#grammar-rule-memberModifier">memberModifier</a></em> | <em><a href="#grammar-rule-visibilityModifier">visibilityModifier</a></em> | <em><a href="#grammar-rule-functionModifier">functionModifier</a></em> | <em><a href="#grammar-rule-propertyModifier">propertyModifier</a></em> | <em><a href="#grammar-rule-inheritanceModifier">inheritanceModifier</a></em> | <em><a href="#grammar-rule-parameterModifier">parameterModifier</a></em> | <em><a href="#grammar-rule-platformModifier">platformModifier</a></em>) {<em><a href="#grammar-rule-NL">NL</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-classModifier" class="grammar-rule">
<dl>
<dt><strong><em>classModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'enum'</code><br />
| <code>'sealed'</code><br />
| <code>'annotation'</code><br />
| <code>'data'</code><br />
| <code>'inner'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-memberModifier" class="grammar-rule">
<dl>
<dt><strong><em>memberModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'override'</code><br />
| <code>'lateinit'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-visibilityModifier" class="grammar-rule">
<dl>
<dt><strong><em>visibilityModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'public'</code><br />
| <code>'private'</code><br />
| <code>'internal'</code><br />
| <code>'protected'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-varianceModifier" class="grammar-rule">
<dl>
<dt><strong><em>varianceModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'in'</code><br />
| <code>'out'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionModifier" class="grammar-rule">
<dl>
<dt><strong><em>functionModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'tailrec'</code><br />
| <code>'operator'</code><br />
| <code>'infix'</code><br />
| <code>'inline'</code><br />
| <code>'external'</code><br />
| <code>'suspend'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-propertyModifier" class="grammar-rule">
<dl>
<dt><strong><em>propertyModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'const'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-inheritanceModifier" class="grammar-rule">
<dl>
<dt><strong><em>inheritanceModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'abstract'</code><br />
| <code>'final'</code><br />
| <code>'open'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-parameterModifier" class="grammar-rule">
<dl>
<dt><strong><em>parameterModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'vararg'</code><br />
| <code>'noinline'</code><br />
| <code>'crossinline'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-reificationModifier" class="grammar-rule">
<dl>
<dt><strong><em>reificationModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'reified'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-platformModifier" class="grammar-rule">
<dl>
<dt><strong><em>platformModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'expect'</code><br />
| <code>'actual'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-label" class="grammar-rule">
<dl>
<dt><strong><em>label</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-IdentifierAt">IdentifierAt</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-annotation" class="grammar-rule">
<dl>
<dt><strong><em>annotation</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-singleAnnotation">singleAnnotation</a></em> | <em><a href="#grammar-rule-multiAnnotation">multiAnnotation</a></em>) {<em><a href="#grammar-rule-NL">NL</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-singleAnnotation" class="grammar-rule">
<dl>
<dt><strong><em>singleAnnotation</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-annotationUseSiteTarget">annotationUseSiteTarget</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em>)<br />
| (<code>'@'</code> <em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiAnnotation" class="grammar-rule">
<dl>
<dt><strong><em>multiAnnotation</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-annotationUseSiteTarget">annotationUseSiteTarget</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'['</code> (<em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em> {<em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em>}) <code>']'</code>)<br />
| (<code>'@'</code> <code>'['</code> (<em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em> {<em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em>}) <code>']'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-annotationUseSiteTarget" class="grammar-rule">
<dl>
<dt><strong><em>annotationUseSiteTarget</em>:</strong></dt>
<dd><span class="sentence"><code>'@field'</code><br />
| <code>'@property'</code><br />
| <code>'@get'</code><br />
| <code>'@set'</code><br />
| <code>'@receiver'</code><br />
| <code>'@param'</code><br />
| <code>'@setparam'</code><br />
| <code>'@delegate'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-unescapedAnnotation" class="grammar-rule">
<dl>
<dt><strong><em>unescapedAnnotation</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-constructorInvocation">constructorInvocation</a></em><br />
| <em><a href="#grammar-rule-userType">userType</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-simpleIdentifier" class="grammar-rule">
<dl>
<dt><strong><em>simpleIdentifier</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-Identifier">Identifier</a></em><br />
| <code>'abstract'</code><br />
| <code>'annotation'</code><br />
| <code>'by'</code><br />
| <code>'catch'</code><br />
| <code>'companion'</code><br />
| <code>'constructor'</code><br />
| <code>'crossinline'</code><br />
| <code>'data'</code><br />
| <code>'dynamic'</code><br />
| <code>'enum'</code><br />
| <code>'external'</code><br />
| <code>'final'</code><br />
| <code>'finally'</code><br />
| <code>'get'</code><br />
| <code>'import'</code><br />
| <code>'infix'</code><br />
| <code>'init'</code><br />
| <code>'inline'</code><br />
| <code>'inner'</code><br />
| <code>'internal'</code><br />
| <code>'lateinit'</code><br />
| <code>'noinline'</code><br />
| <code>'open'</code><br />
| <code>'operator'</code><br />
| <code>'out'</code><br />
| <code>'override'</code><br />
| <code>'private'</code><br />
| <code>'protected'</code><br />
| <code>'public'</code><br />
| <code>'reified'</code><br />
| <code>'sealed'</code><br />
| <code>'tailrec'</code><br />
| <code>'set'</code><br />
| <code>'vararg'</code><br />
| <code>'where'</code><br />
| <code>'expect'</code><br />
| <code>'actual'</code><br />
| <code>'const'</code><br />
| <code>'suspend'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-identifier" class="grammar-rule">
<dl>
<dt><strong><em>identifier</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code> <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-shebangLine" class="grammar-rule">
<dl>
<dt><strong><em>shebangLine</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-ShebangLine">ShebangLine</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-quest" class="grammar-rule">
<dl>
<dt><strong><em>quest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-QUEST_NO_WS">QUEST_NO_WS</a></em><br />
| <em><a href="#grammar-rule-QUEST_WS">QUEST_WS</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-elvis" class="grammar-rule">
<dl>
<dt><strong><em>elvis</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-QUEST_NO_WS">QUEST_NO_WS</a></em> <code>':'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-safeNav" class="grammar-rule">
<dl>
<dt><strong><em>safeNav</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-QUEST_NO_WS">QUEST_NO_WS</a></em> <code>'.'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-excl" class="grammar-rule">
<dl>
<dt><strong><em>excl</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-EXCL_NO_WS">EXCL_NO_WS</a></em><br />
| <em><a href="#grammar-rule-EXCL_WS">EXCL_WS</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-semi" class="grammar-rule">
<dl>
<dt><strong><em>semi</em>:</strong></dt>
<dd><span class="sentence">((<code>';'</code> | <em><a href="#grammar-rule-NL">NL</a></em>) {<em><a href="#grammar-rule-NL">NL</a></em>})<br />
| <em><a href="#grammar-rule-EOF">EOF</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-semis" class="grammar-rule">
<dl>
<dt><strong><em>semis</em>:</strong></dt>
<dd><span class="sentence">(<code>';'</code> | <em><a href="#grammar-rule-NL">NL</a></em> {<code>';'</code> | <em><a href="#grammar-rule-NL">NL</a></em>})<br />
| <em><a href="#grammar-rule-EOF">EOF</a></em></span>
</dd>
</dl>
</div>
<h2 id="type-system">Type system</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Add examples)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Add grammar snippets?)</span></p>
</div>
</div>
<h3 id="glossary-1">Glossary</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Cleanup)</span></p>
</div>
</div>
<dl>
<dt><span class="math inline">\(T\)</span></dt>
<dd><span class="sentence">Type</span>
</dd>
<dt><span class="math inline">\(T!!\)</span></dt>
<dd><span class="sentence">Non-nullable type</span>
</dd>
<dt><span class="math inline">\(T?\)</span></dt>
<dd><span class="sentence">Nullable type</span>
</dd>
<dt><span class="math inline">\(\{T!!\}\)</span></dt>
<dd><span class="sentence">Universe of non-nullable types</span>
</dd>
<dt><span class="math inline">\(\{T?\}\)</span></dt>
<dd><span class="sentence">Universe of nullable types</span>
</dd>
<dt><span class="math inline">\(\Gamma\)</span></dt>
<dd><span class="sentence">Type context</span>
</dd>
<dt><span class="math inline">\(T\lbrack S_1, \ldots, S_n\rbrack\)</span></dt>
<dd><span class="sentence">The result of type argument substitution for type <span class="math inline">\(T\)</span> with types <span class="math inline">\(S_i\)</span></span>
</dd>
<dt><span class="math inline">\(A \operatorname{\&amp;}B\)</span></dt>
<dd><span class="sentence">Intersection type intersecting A and B</span>
</dd>
<dt>Type parameter</dt>
<dd><span class="sentence">Formal type argument of parameterized type</span>
</dd>
<dt>Type argument</dt>
<dd><span class="sentence">Actual type argument in parameterized type constructor application</span>
</dd>
<dt>PACT</dt>
<dd><span class="sentence">Parameterized abstract classifier type</span>
</dd>
<dt>iPACT</dt>
<dd><span class="sentence">Instantiated parameterized concrete classifier type</span>
</dd>
</dl>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Not everything is in the glossary, make some criteria)</span></p>
</div>
</div>
<h3 id="introduction-1">Introduction</h3>
<div class="paragraph">
<p><span class="sentence">Kotlin has a type system with the following main properties.</span></p>
</div>
<ul>
<li><span class="sentence">Hybrid static and gradual type checking</span></li>
<li><span class="sentence">Null safety</span></li>
<li><span class="sentence">No unsafe implicit conversions</span></li>
<li><span class="sentence">Unified root type</span></li>
<li><span class="sentence">Nominal subtyping with bounded parametric polymorphism and mixed-site variance</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(static type checking, gradual type checking)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Null safety is enforced by having two type universes â€” <em>nullable</em> (with nullable types <span class="math inline">\(T?\)</span>) and <em>non-nullable</em> (with non-nullable types <span class="math inline">\(T!!\)</span>). </span><span class="sentence">All operations within the non-nullable type universe are safe, i.e., should never cause a runtime null pointer error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Implicit conversions between types in Kotlin are limited to safe upcasts w.r.t. subtyping, meaning all other (unsafe) conversions must be explicit, done via either a conversion function or an <a href="#cast-expression">explicit cast</a>. </span><span class="sentence">However, Kotlin also supports smart casts â€” a special kind of implicit conversions which are safe w.r.t. program control- and data-flow, which are covered in more detail <a href="#smart-casts">here</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The unified supertype type for all types in Kotlin is <code>kotlin.Any?</code>, a nullable version of <a href="#kotlin.any">kotlin.Any</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Kotlin uses nominal subtyping, meaning subtyping relation is defined when a type is declared, with bounded parametric polymorphism, implemented as <a href="#generics">generics</a> via <a href="#parameterized-classifier-types">parameterized types</a>. </span><span class="sentence">Subtyping between these parameterized types is defined through <a href="#mixed-site-variance">mixed-site variance</a>.</span></p>
</div>
<h3 id="type-kinds">Type kinds</h3>
<div class="paragraph">
<p><span class="sentence">For the purposes of this section, we establish the following type kinds â€” different flavours of types which exist in the Kotlin type system.</span></p>
</div>
<ul>
<li><span class="sentence"><a href="#built-in-types">Built-in types</a></span></li>
<li><span class="sentence"><a href="#classifier-types">Classifier types</a></span></li>
<li><span class="sentence"><a href="#function-types">Function types</a></span></li>
<li><span class="sentence"><a href="#array-types">Array types</a></span></li>
<li><span class="sentence"><a href="#flexible-types">Flexible types</a></span></li>
<li><span class="sentence"><a href="#nullable-types">Nullable types</a></span></li>
<li><span class="sentence"><a href="#intersection-types">Intersection types</a></span></li>
<li><div class="TODO">
<span class="sentence">TODO(GLB, LUB)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(Error / invalid types)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">We distinguish between <em>concrete</em> and <em>abstract</em> types. </span><span class="sentence">Concrete types are types which are assignable to values; abstract types either need to be instantiated as concrete types before they can be used as value types, or are used internally by the type system and are not directly denotable.</span></p>
</div>
<h4 id="built-in-types">Built-in types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin type system uses the following built-in types, which have special semantics and representation (or lack thereof).</span></p>
</div>
<h5 id="kotlin.any"><code>kotlin.Any</code></h5>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Any</code> is the unified supertype (<span class="math inline">\(\top\)</span>) for <span class="math inline">\(\{T!!\}\)</span>, i.e., all non-nullable types are subtypes of <code>kotlin.Any</code>, either explicitly, implicitly, or by subtyping relation.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<code>kotlin.Any</code> members?)</span></p>
</div>
</div>
<h5 id="kotlin.nothing"><code>kotlin.Nothing</code></h5>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Nothing</code> is the unified subtype (<span class="math inline">\(\bot\)</span>) for <span class="math inline">\(\{T!!\}\)</span>, i.e., <code>kotlin.Nothing</code> is a subtype of all non-nullable types, including user-defined ones. </span><span class="sentence">This makes it an uninhabited type (as it is impossible for anything to be, for example, a function and an integer at the same time), meaning instances of this type can never exist at runtime; subsequently, there is no way to create an instance of <code>kotlin.Nothing</code> in Kotlin.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">As the evaluation of an expression with <code>kotlin.Nothing</code> type can never complete normally, it is used to mark special situations, such as:</span></p>
</div>
<ul>
<li><span class="sentence">non-terminating expressions</span></li>
<li><span class="sentence">exceptional control flow</span></li>
<li><span class="sentence">control flow transfer</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Additional details about how <code>kotlin.Nothing</code> should be processed are available <a href="#control--and-data-flow-analysis">here</a>.</span></p>
</div>
<h5 id="kotlin.unit"><code>kotlin.Unit</code></h5>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Unit</code> is a unit type, i.e., a type with only one value <code>kotlin.Unit</code>; all values of type <code>kotlin.Unit</code> should reference the same underlying <code>kotlin.Unit</code> object.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Compare to <code>void</code>?)</span></p>
</div>
</div>
<h5 id="kotlin.function"><code>kotlin.Function</code></h5>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Function&lt;R&gt;</code> is the unified supertype of all <a href="#function-types">function types</a>. </span><span class="sentence">It is parameterized over function return type <code>R</code>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Elaborate about the parameter, or maybe in function type section?)</span></p>
</div>
</div>
<h4 id="classifier-types">Classifier types</h4>
<div class="paragraph">
<p><span class="sentence">Classifier types represent regular types which are declared as [classes][Classes], [interfaces][Interfaces] or [objects][Objects]. </span><span class="sentence">As Kotlin supports <a href="#generics">generics</a>, there are two variants of classifier types: simple and parameterized.</span></p>
</div>
<h5 id="simple-classifier-types">Simple classifier types</h5>
<div class="paragraph">
<p><span class="sentence">A simple concrete classifier type</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[T : S_1, \ldots, S_m\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">consists of</span></p>
</div>
<ul>
<li><span class="sentence">type name <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence">(optional) list of supertypes <span class="math inline">\(S_1, \ldots, S_m\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a valid simple concrete classifier type, <span class="math inline">\(T : S_1, \ldots, S_m\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a valid type name</span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,m]: S_i\)</span> must be concrete, non-nullable, valid type</span></li>
</ul>
<h5 id="parameterized-classifier-types">Parameterized classifier types</h5>
<div class="paragraph">
<p><span class="sentence">A parameterized abstract classifier type (PACT)</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[T(F_1, \ldots, F_n) : S_1, \ldots, S_m\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">consists of</span></p>
</div>
<ul>
<li><span class="sentence">type constructor <span class="math inline">\(T\)</span> which takes type arguments and returns an instantiated type</span></li>
<li><span class="sentence">type parameters <span class="math inline">\(F_1, \ldots, F_n\)</span></span></li>
<li><span class="sentence">(optional) list of supertypes <span class="math inline">\(S_1, \ldots, S_m\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a valid PACT, <span class="math inline">\(T(F_1, \ldots, F_n) : S_1, \ldots, S_m\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a valid type name</span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: F_i\)</span> must be one of the following kinds</span>
<ul>
<li><span class="sentence">[unbounded type parameter][Unbounded type parameters]</span></li>
<li><span class="sentence">[projected type parameter][Projected type parameters]</span></li>
<li><span class="sentence"><a href="#bounded-type-parameters">bounded type parameter</a></span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(\forall j \in [1,m]: S_j[F_1, \ldots, F_n]\)</span> must be concrete, non-nullable, valid type</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">An instantiated parameterized concrete classifier type (iPACT)</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[T[A_1, \ldots, A_n]\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">consists of</span></p>
</div>
<ul>
<li><span class="sentence">PACT <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence">type arguments <span class="math inline">\(A_1, \ldots, A_n\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a valid iPACT, <span class="math inline">\(T[A_1, \ldots, A_n]\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a valid PACT with <span class="math inline">\(n\)</span> type parameters</span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: A_i\)</span> must be one of the following kinds</span>
<ul>
<li><span class="sentence">valid concrete type</span></li>
<li><span class="sentence">valid projected type</span></li>
<li><span class="sentence">type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span>
<ul>
<li><div class="TODO">
<span class="sentence">TODO(What is a type context?)<br />
</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(Inner vs nested contexts)</span>
</div></li>
</ul></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: A_i &lt;: F_i\)</span> where <span class="math inline">\(F_i\)</span> is the respective type parameter of <span class="math inline">\(T\)</span></span></li>
</ul>
<h5 id="type-parameters">Type parameters</h5>
<div class="paragraph">
<p><span class="sentence">Type parameters are a special kind of abstract types, which are introduced by PACTs. </span><span class="sentence">They are valid only in the context of their declaring PACT.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When creating an iPACT from PACT, type parameters with their respective type arguments go through <a href="#type-capturing">capturing</a> and create <em>captured</em> type arguments, which follow special rules described in more detail below.</span></p>
</div>
<h6 id="bounded-type-parameters">Bounded type parameters</h6>
<div class="paragraph">
<p><span class="sentence">A bounded type parameter is an abstract type which is used to specify upper type bounds for type parameters and is defined as <span class="math inline">\(F &lt;: B_1, \ldots, B_n\)</span>, where <span class="math inline">\(B_i\)</span> is an i-th upper bound on type parameter <span class="math inline">\(F\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a valid bounded type parameter of PACT <span class="math inline">\(T\)</span>, <span class="math inline">\(F &lt;: B_1, \ldots, B_n\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter of PACT <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: B_i\)</span> must be one of the following kinds</span>
<ul>
<li><span class="sentence">valid concrete type</span></li>
<li><span class="sentence">a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Single generic bound allowed)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Only one class bound allowed)</span></p>
</div>
</div>
<h6 id="mixed-site-variance">Mixed-site variance</h6>
<div class="paragraph">
<p><span class="sentence">To implement subtyping between parameterized types, Kotlin uses <em>mixed-site variance</em> â€” a combination of declaration- and use-site variance, which is easier to understand and reason about, compared to wildcards from Java. </span><span class="sentence">Mixed-site variance means you can specify, whether you want your parameterized type to be co-, contra- or invariant on some type parameter, both in type parameter (declaration-site) and type argument (use-site). </span><span class="sentence">For more practical discussion about mixed-site variance, we readdress you to <a href="#generics">generics</a>.</span></p>
</div>
<h6 id="declaration-site-variance">Declaration-site variance</h6>
<div class="paragraph">
<p><span class="sentence">An invariant type parameter <span class="math inline">\(F\)</span> is an abstract type which may capture any valid type (see <a href="#subtyping">subtyping</a> for more details on variance); if one needs co- or contravariant type parameter, they need to use projected type parameters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a valid invariant type parameter of PACT <span class="math inline">\(T\)</span>, <span class="math inline">\(F\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Projected type parameters are abstract types which are used to declare a type parameter as <em>covariant</em> or <em>contravariant</em>. </span><span class="sentence">The variance information is used by <a href="#subtyping">subtyping</a> and for checking allowed operations on values of co- and contravariant type parameters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a valid covariant type parameter <span class="math inline">\(\triangleleft F\)</span> of PACT <span class="math inline">\(T\)</span>, <span class="math inline">\(\triangleleft F\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a valid contravariant type parameter <span class="math inline">\(\triangleright F\)</span> of PACT <span class="math inline">\(T\)</span>, <span class="math inline">\(\triangleright F\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(type projections are not allowed on functions and properties)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(no type projections on supertype type arguments)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(conflicting projections)</span></p>
</div>
</div>
<h6 id="use-site-variance">Use-site variance</h6>
<div class="paragraph">
<p><span class="sentence">Kotlin also supports use-site variance, by specifying the variance for type arguments. </span><span class="sentence">Just like with projected type parameters, one can have projected type arguments being co-, contra- or invariant.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a valid invariant type argument of iPACT <span class="math inline">\(T\)</span>, <span class="math inline">\(A\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span> must be one of the following kinds</span>
<ul>
<li><span class="sentence">a valid concrete type</span></li>
<li><span class="sentence">a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a valid covariant type argument <span class="math inline">\(\triangleleft A\)</span> of iPACT <span class="math inline">\(T\)</span>, <span class="math inline">\(\triangleleft A\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span> must be one of the following kinds</span>
<ul>
<li><span class="sentence">a valid concrete type</span></li>
<li><span class="sentence">a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a valid contravariant type argument <span class="math inline">\(\triangleright A\)</span> of iPACT <span class="math inline">\(T\)</span>, <span class="math inline">\(\triangleright A\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span> must be one of the following kinds</span>
<ul>
<li><span class="sentence">a valid concrete type</span></li>
<li><span class="sentence">a type parameter available in the current type context <span class="math inline">\(\Gamma\)</span></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">In case one cannot specify any valid type argument, but still needs to use PACT in a type-safe way, one may use <em>star-projected</em> type argument, which is roughly equivalent to a combination of <span class="math inline">\(\triangleleft \texttt{kotlin.Any?}\)</span> and <span class="math inline">\(\triangleright \texttt{kotlin.Nothing}\)</span> (for further details, see <a href="#generics">here</a>).</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Clean-up this mess)</span></p>
</div>
</div>
<h5 id="type-capturing">Type capturing</h5>
<div class="paragraph">
<p><span class="sentence">Type capturing (similarly to Java capturing conversion) is used when instantiating parameterized types; it creates <em>captured</em> types based on the type information of both type parameters and arguments, which present a unified view on the resulting types and simplifies further reasoning.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For a given PACT <span class="math inline">\(T(F_1, \ldots, F_n) : S_1, \ldots, S_m\)</span>, its iPACT <span class="math inline">\(T[A_1, \ldots, A_n]\)</span> uses the following rules to create captured type <span class="math inline">\(C_i\)</span> from the type parameter <span class="math inline">\(F_i\)</span> and type argument <span class="math inline">\(A_i\)</span>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Does this set describe a type universe?)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Blah-blah about existential types?)</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">NB: A captured type <span class="math inline">\(C\)</span> may be viewed as a set of its type constraints <span class="math inline">\(\mathbb{C}\)</span>. </span><span class="sentence"><strong>All</strong> applicable rules are used to create the resulting constraint set.</span></p>
</div>
</blockquote>
<ul>
<li><span class="sentence">If <span class="math inline">\(\triangleleft F_i\)</span> is a covariant type parameter and <span class="math inline">\(A_i\)</span> is not a concrete type, covariant or star-projected type argument, it is an error. </span><span class="sentence">Otherwise, <span class="math inline">\(C_i &lt;: A_i\)</span>.</span></li>
<li><span class="sentence">If <span class="math inline">\(\triangleright F_i\)</span> is a contravariant type parameter and <span class="math inline">\(A_i\)</span> is not a concrete type, contravariant or star-projected type argument, it is an error. </span><span class="sentence">Otherwise, <span class="math inline">\(C_i :&gt; A_i\)</span>.</span></li>
<li><span class="sentence">If <span class="math inline">\(F_i &lt;: B_1, \ldots, B_n\)</span> is a bounded type parameter, <span class="math inline">\(C_i &lt;: B_i[C_1, \ldots, C_n]\)</span></span></li>
<li><span class="sentence">If <span class="math inline">\(\triangleleft A_i\)</span> is a covariant type argument, <span class="math inline">\(C_i &lt;: A_i\)</span></span></li>
<li><span class="sentence">If <span class="math inline">\(\triangleright A_i\)</span> is a contravariant type argument, <span class="math inline">\(C_i :&gt; A_i\)</span></span></li>
<li><span class="sentence">If <span class="math inline">\(\star A_i\)</span> is a star-projected type argument, <span class="math inline">\(kotlin.Nothing &lt;: C_i &lt;: kotlin.Any?\)</span></span></li>
<li><span class="sentence">Otherwise, <span class="math inline">\(C_i = A_i\)</span></span></li>
</ul>
<h4 id="function-types">Function types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin has first-order functions; e.g., it supports function types, which describe the argument and return types of its corresponding function.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A function type FT</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[FT(A_1, \ldots, A_n) \rightarrow R\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">consists of</span></p>
</div>
<ul>
<li><span class="sentence">argument types <span class="math inline">\(A_i\)</span></span></li>
<li><span class="sentence">return type <span class="math inline">\(R\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and may be considered the following instantiation of a special parameterized abstract classifier type <span class="math inline">\(FunctionN\)</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[FunctionN(\triangleleft P_1, \ldots, \triangleleft P_n, \triangleright RT)\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[FT(A_1, \ldots, A_n) \rightarrow R \equiv FunctionN[A_1, \ldots, A_n, R]\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">These <span class="math inline">\(FunctionN\)</span> types follow the rules of regular PACTs w.r.t. subtyping.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A function type with receiver FTR</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[FTR(TH, A_1, \ldots, A_n) \rightarrow R\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">consists of</span></p>
</div>
<ul>
<li><span class="sentence">receiver type <span class="math inline">\(TH\)</span></span></li>
<li><span class="sentence">argument types <span class="math inline">\(A_i\)</span></span></li>
<li><span class="sentence">return type <span class="math inline">\(R\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">From the type systemâ€™s point of view, it is equivalent to the following function type</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[FTR(TH, A_1, \ldots, A_n) \rightarrow R \equiv FT(TH, A_1, \ldots, A_n) \rightarrow R\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">i.e., receiver is considered as yet another argument of its function type.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means that, for example, these two types are equivalent</span></p>
</div>
<ul>
<li><span class="sentence"><code>Int.(Int) -&gt; String</code></span></li>
<li><span class="sentence"><code>(Int, Int) -&gt; String</code></span></li>
</ul>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(The relation between function types and classifier types (every function is actually an interface, <code>kotlin.Function</code> is also an interface))</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(The variance of arguments for function types)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Make the decision about notation (right now it is shaky a.f.))</span></p>
</div>
</div>
<h4 id="array-types">Array types</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Everythingâ€¦)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Primitive type array coercion)</span></p>
</div>
</div>
<h4 id="flexible-types">Flexible types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin, being a multi-platform language, needs to support transparent interoperability with platform-dependent code. </span><span class="sentence">However, this presents a problem in that some platforms may not support null safety the way Kotlin does. </span><span class="sentence">To deal with this, Kotlin supports <em>gradual typing</em> in the form of flexible types.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A flexible type represents a range of possible types between type <span class="math inline">\(L\)</span> (lower bound) and type <span class="math inline">\(U\)</span> (upper bound), written as <span class="math inline">\((L..U)\)</span>. </span><span class="sentence">One should note flexible types are abstract and <em>non-denotable</em>, i.e., one cannot explicitly declare a variable with flexible type, these types are created by the type system when needed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a valid flexible type, <span class="math inline">\((L..U)\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> are valid concrete types</span></li>
<li><span class="sentence"><span class="math inline">\(L &lt;: U\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\neg (L &lt;: U)\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> are <strong>not</strong> flexible types (but may contains other flexible types as part of their type signature)</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">As the name suggests, flexible types are flexible â€” a value of type <span class="math inline">\((L..U)\)</span> can be used in any context, where one of the possible types between <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> is needed (for more details, see <a href="#subtyping">subtyping rules for flexible types</a>). </span><span class="sentence">However, the actual type will be a specific type between <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span>, thus making the substitution possibly unsafe, which is why Kotlin generates dynamic assertions, when it is impossible to prove statically the safety of flexible type use.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Details of assertion generation?)</span></p>
</div>
</div>
<h5 id="platform-types">Platform types</h5>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Platform types as flexible types)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Reference for different platforms)</span></p>
</div>
</div>
<h4 id="nullable-types">Nullable types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin supports null safety by having two type universes â€” nullable and non-nullable. </span><span class="sentence">All classifier type declarations, built-in or user-defined, create non-nullable types, i.e., types which cannot hold <code>null</code> value at runtime.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To specify a nullable version of type <code>T</code>, one needs to use <code>T?</code> as a type. </span><span class="sentence">Redundant nullability specifiers are ignored â€” <code>T???</code> is equivalent to <code>T?</code>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Informally, question mark means â€œ<span class="math inline">\(T?\)</span> may hold values of type <span class="math inline">\(T\)</span> or value <code>null</code>â€</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">To represent a valid nullable type, <span class="math inline">\(T?\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a valid type</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If an operation is safe regardless of absence or presence of <code>null</code>, i.e., assignment of one nullable value to another, it can be used as-is for nullable types. </span><span class="sentence">For operations on <span class="math inline">\(T?\)</span> which may violate null safety, one has the following null-safe options:</span></p>
</div>
<ol type="1">
<li><span class="sentence">Use safe operations</span>
<ul>
<li><span class="sentence">[safe call][Safe call expression]</span></li>
</ul></li>
<li><span class="sentence">Downcast from <span class="math inline">\(T?\)</span> to <span class="math inline">\(T!!\)</span></span>
<ul>
<li><span class="sentence"><a href="#cast-expression">unsafe cast</a></span></li>
<li><span class="sentence">[type check][Type check expression] combined with <a href="#smart-casts">smart casts</a></span></li>
<li><span class="sentence">null check combined with <a href="#smart-casts">smart casts</a></span></li>
<li><span class="sentence">[not-null assertion operator][Not-null assertion operator expression]</span></li>
</ul></li>
<li><span class="sentence">Supply a default value to use instead of <code>null</code></span>
<ul>
<li><span class="sentence"><a href="#elvis-operator-expression">elvis operator</a></span></li>
</ul></li>
</ol>
<h4 id="intersection-types">Intersection types</h4>
<div class="paragraph">
<p><span class="sentence">Intersection types are special non-denotable types that are used to express (loosely) that a value has two or more types to choose from. </span><span class="sentence">Intersection type of two non-nullable types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is denoted <span class="math inline">\(A \operatorname{\&amp;}B\)</span>. </span><span class="sentence">Intersection types are used for <a href="#smart-casts">smart casting</a>. </span><span class="sentence">Intersection types are commutative and associative, meaning that <span class="math inline">\(A \operatorname{\&amp;}B\)</span> is the same type as <span class="math inline">\(B \operatorname{\&amp;}A\)</span> and <span class="math inline">\(A \operatorname{\&amp;}(B \operatorname{\&amp;}C)\)</span> is the same type as <span class="math inline">\(A \operatorname{\&amp;}B \operatorname{\&amp;}C\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For presentation purposes, we will normalize intersection type operands lexicographically based on their notation.</span></p>
</div>
<h5 id="type-intersection">Type intersection</h5>
<div class="paragraph">
<p><span class="sentence">The primary operation on types that is used to construct intersection types is called type intersection (do not confuse the two). </span><span class="sentence">Type intersection <span class="math inline">\(A \times B\)</span> of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> has the following properties:</span></p>
</div>
<ul>
<li><span class="sentence">it is commutative and associative, just like set intersection (for simplicity, all other properties will be shown for only one order of operands, meaning they hold under both commutativity and associativity)</span></li>
<li><span class="sentence">it is idempotent, meaning that <span class="math inline">\(A \times A = A\)</span></span></li>
<li><span class="sentence">if <span class="math inline">\(A &lt;: B\)</span> then <span class="math inline">\(A \times B = A\)</span></span>
<ul>
<li><span class="sentence"><span class="math inline">\(\times\)</span> has identity at <code>kotlin.Any</code>: <span class="math inline">\(\forall T . T \times \mathtt{kotlin.Any} = T\)</span></span></li>
</ul></li>
<li><span class="sentence">if <span class="math inline">\(A\)</span> is non-nullable, than <span class="math inline">\(A \times B\)</span> is also non-nullable</span></li>
<li><span class="sentence">if both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are nullable, <span class="math inline">\(A \times B = (A!! \times B!!)?\)</span></span></li>
<li><span class="sentence">if type <span class="math inline">\(A\)</span> is nullable and type <span class="math inline">\(B\)</span> is not, <span class="math inline">\(A \times B = A!! \times B\)</span></span></li>
<li><span class="sentence">if both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are non-nullable and no other rules apply, <span class="math inline">\(A \times B = A \operatorname{\&amp;}B\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">These properties have several important implications:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\forall A, B : (A \times B) &lt;: A \land (A \times B) &lt;: B\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\forall A, B, C : C &lt;: (A \times C) &lt;: B \implies C &lt;: (A \times B)\)</span>.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Prove the implications??)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Intersection of flexible types)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Intersection of generics)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(If <span class="math inline">\(A &lt;: B\)</span> and <span class="math inline">\(B &lt;: A\)</span>, what is <span class="math inline">\(A \times B\)</span>???)</span></p>
</div>
</div>
<h3 id="subtyping">Subtyping</h3>
<div class="paragraph">
<p><span class="sentence">Kotlin uses the classic notion of <em>subtyping</em> as <em>substitutability</em> â€” if <span class="math inline">\(S\)</span> is a subtype of <span class="math inline">\(T\)</span> (denoted as <span class="math inline">\(S &lt;: T\)</span>), values of type <span class="math inline">\(S\)</span> can be safely used where values of type <span class="math inline">\(T\)</span> are expected. </span><span class="sentence">The subtyping relation <span class="math inline">\(&lt;:\)</span> is:</span></p>
</div>
<ul>
<li><span class="sentence">reflexive (<span class="math inline">\(A &lt;: A\)</span>)</span></li>
<li><span class="sentence">transitive (<span class="math inline">\(A &lt;: B \land B &lt;: C \Rightarrow A &lt;: C\)</span>)</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Two types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are <em>equivalent</em> (<span class="math inline">\(A \equiv B\)</span>), iff <span class="math inline">\(A &lt;: B \land B &lt;: A\)</span>. </span><span class="sentence">Due to the presence of flexible types, this relation is <strong>not</strong> transitive (see <a href="#subtyping-for-flexible-types">here</a> for more details).</span></p>
</div>
<h4 id="subtyping-rules">Subtyping rules</h4>
<div class="paragraph">
<p><span class="sentence">Subtyping for non-nullable, concrete types uses the following rules.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\forall T : \text{kotlin.Nothing} &lt;: T &lt;: \text{kotlin.Any}\)</span></span></li>
<li><span class="sentence">For any simple classifier type <span class="math inline">\(T : S_1, \ldots, S_m\)</span> it is true that <span class="math inline">\(\forall i \in [1,m]: T &lt;: S_i\)</span></span></li>
<li><span class="sentence">For any iPACT <span class="math inline">\(\widehat{T} = T(F_1, \ldots, F_n)[A_1, \ldots, A_n] : S_1, \ldots, S_m\)</span> with captured type arguments <span class="math inline">\(C_1, \ldots, C_n\)</span> it is true that <span class="math inline">\(\forall i \in [1,m]: \widehat{T} &lt;: S_i[C_1, \ldots, C_n]\)</span></span></li>
<li><span class="sentence">For any two iPACTs <span class="math inline">\(\widehat{T}\)</span> and <span class="math inline">\(\widehat{T^\prime}\)</span> with captured type arguments <span class="math inline">\(C_i\)</span> and <span class="math inline">\(C_i^\prime\)</span> it is true that <span class="math inline">\(\widehat{T} &lt;: \widehat{T^\prime}\)</span> if <span class="math inline">\(\forall i \in [1,n]: C_i &lt;: C_i^\prime\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Subtyping for non-nullable, abstract types uses the following rules.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\forall T : \text{kotlin.Nothing} &lt;: T &lt;: \text{kotlin.Any}\)</span></span></li>
<li><span class="sentence">For any PACT <span class="math inline">\(\widehat{T} = T(F_1, \ldots, F_n) : S_1, \ldots, S_m\)</span> it is true that <span class="math inline">\(\forall i \in [1,m]: \widehat{T} &lt;: S_i\)</span></span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Subtyping for type parameters)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Subtyping for non-nullable, captured types uses rules of different kind, as captured type <span class="math inline">\(C\)</span> describes not one, but a set of types which satisfy its type constraints <span class="math inline">\(\mathbb{C}\)</span>. </span><span class="sentence">Therefore, we use the following subtyping rules for captured types.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\forall C : \text{kotlin.Nothing} &lt;: C &lt;: \text{kotlin.Any}\)</span></span></li>
<li><span class="sentence">For any two captured types <span class="math inline">\(C\)</span> and <span class="math inline">\(C^\prime\)</span>, <span class="math inline">\(C &lt;: C^\prime\)</span> if <span class="math inline">\(\forall T : \mathbb{C}(T) \Rightarrow \mathbb{C^\prime}(T)\)</span> (i.e., a set of types for <span class="math inline">\(C\)</span> is a subset of a set of types for <span class="math inline">\(C^\prime\)</span>)</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Subtyping for nullable types is checked separately and uses a special set of rules which are described <a href="#subtyping-for-nullable-types">here</a>.</span></p>
</div>
<h4 id="subtyping-for-flexible-types">Subtyping for flexible types</h4>
<div class="paragraph">
<p><span class="sentence">Flexible types (being flexible) follow a simple subtyping relation with other inflexible types. </span><span class="sentence">Let <span class="math inline">\(T, A, B, L, U\)</span> be inflexible types.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(L &lt;: T \Rightarrow (L..U) &lt;: T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(T &lt;: U \Rightarrow T &lt;: (L..U)\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This captures the notion of flexible type <span class="math inline">\((L..U)\)</span> as something which may be used in place of any type in between <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span>. </span><span class="sentence">If we are to extend this idea to subtyping between <em>two</em> flexible types, we get the following definition.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(L &lt;: B \Rightarrow (L..U) &lt;: (A..B)\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This is the most extensive definition possible, which, unfortunately, makes the type equivalence relation non-transitive. </span><span class="sentence">Let <span class="math inline">\(A, B\)</span> be two <em>different</em> types, for which <span class="math inline">\(A &lt;: B\)</span>. </span><span class="sentence">The following relations hold:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A &lt;: (A..B) \land (A..B) &lt;: A \Rightarrow A \equiv (A..B)\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(B &lt;: (A..B) \land (A..B) &lt;: B \Rightarrow B \equiv (A..B)\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">However, <span class="math inline">\(A \not \equiv B\)</span>.</span></p>
</div>
<h4 id="subtyping-for-intersection-types">Subtyping for intersection types</h4>
<div class="paragraph">
<p><span class="sentence">Intersection types introduce several new rules for subtyping. </span><span class="sentence">Let <span class="math inline">\(A, B, C, D\)</span> be non-nullable types:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A \operatorname{\&amp;}B &lt;: A\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \operatorname{\&amp;}B &lt;: B\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A &lt;: C \land B &lt;: D \Rightarrow A \operatorname{\&amp;}B &lt;: C \operatorname{\&amp;}D\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">More, any type <span class="math inline">\(T\)</span> with supertypes <span class="math inline">\(S_1, S_2, S_3, \ldots, S_N\)</span> is also a subtype of <span class="math inline">\(S_1 \operatorname{\&amp;}S_2 \operatorname{\&amp;}S_3 \operatorname{\&amp;}\ldots \operatorname{\&amp;}S_N\)</span>.</span></p>
</div>
<h4 id="subtyping-for-nullable-types">Subtyping for nullable types</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Why canâ€™t we just say that <span class="math inline">\(\forall T : T &lt;: T?\)</span> and <span class="math inline">\(\forall T : T!! &lt;: T\)</span> and be done with it?)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Subtyping for two possibly nullable types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is defined via <em>two</em> relations, both of which must hold.</span></p>
</div>
<ul>
<li><span class="sentence">Regular subtyping <span class="math inline">\(&lt;:\)</span> for non-nullable types <span class="math inline">\(A!!\)</span> and <span class="math inline">\(B!!\)</span></span></li>
<li><span class="sentence">Subtyping by nullability <span class="math inline">\(\stackrel{null}{&lt;:}\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Subtyping by nullability <span class="math inline">\(\stackrel{null}{&lt;:}\)</span> for two possibly nullable types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> uses the following rules.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A!! \stackrel{null}{&lt;:}B\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \stackrel{null}{&lt;:}B\)</span> if <span class="math inline">\(\exists T!! : A &lt;: T!!\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \stackrel{null}{&lt;:}B?\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \stackrel{null}{&lt;:}B\)</span> if <span class="math inline">\(\not \exists T!! : B &lt;: T!!\)</span></span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(How the existence check works)</span></p>
</div>
</div>
<h3 id="generics">Generics</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(How is generics different from type parameters? </span><span class="sentence">Or are we going to get into deep technical detail?)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Here be a lot of dragonsâ€¦)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Type parameters are considered to be non-nullable, even if they are not suchâ€¦)</span></p>
</div>
</div>
<h3 id="upper-and-lower-bounds">Upper and lower bounds</h3>
<div class="paragraph">
<p><span class="sentence">A type <span class="math inline">\(U\)</span> is an <em>upper bound</em> of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> if <span class="math inline">\(A &lt;: U\)</span> and <span class="math inline">\(B &lt;: U\)</span>. </span><span class="sentence">A type <span class="math inline">\(L\)</span> is a <em>lower bound</em> of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> if <span class="math inline">\(L &lt;: A\)</span> and <span class="math inline">\(L &lt;: B\)</span>. </span><span class="sentence">As the type system of Kotlin is bounded by definition (the upper bound of all types being <span class="math inline">\(\text{kotlin.Any}?\)</span>, while the lower bound of all types being <span class="math inline">\(\text{kotlin.Nothing}\)</span>, see the rest of this section for details), any two types have at least one lower bound and at least one upper bound.</span></p>
</div>
<h4 id="least-upper-bound">Least upper bound</h4>
<div class="paragraph">
<p><span class="sentence">The <em>least upper bound</em> of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is an upper bound <span class="math inline">\(U\)</span> of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> such that there is no other upper bound of these types that is less (by subtyping relation) than <span class="math inline">\(U\)</span>. </span><span class="sentence">Note that among the supertypes of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> there may be several types that adhere to these properties and are not related by subtyping. </span><span class="sentence">In such situation, an intersection of these types is the least upper bound of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, as, by definition, the intersection <span class="math inline">\(I\)</span> of types <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> is less than both <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>.</span></p>
</div>
<ul>
<li><div class="TODO">
<span class="sentence">TODO(but what if there are equivalent types arising?)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(check this for shady cases)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(actual algorithm for computing LUB)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(generics, especially contravariant TP, make the enumeration impossible, but GLB saves the day)</span>
</div></li>
</ul>
<h4 id="greatest-lower-bound">Greatest lower bound</h4>
<div class="paragraph">
<p><span class="sentence">The <em>greatest lower bound</em> of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is a lower bound <span class="math inline">\(L\)</span> of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> such that there is no other lower bound of these types that is greater by subtyping relation than <span class="math inline">\(L\)</span>. </span><span class="sentence">Enumerating all subtypes of a given type is impossible in general, but may easily be show that, in the presense of intersection types (<a href="#type-intersection">again, see type intersection section</a>), an intersection of any given types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is always the greatest lower bound of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: letâ€™s assume that there is a type <span class="math inline">\(C\)</span> that is not an intersection of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, but is the greatest lower bound of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. </span><span class="sentence">This, by definition of type intersection, means that it is a subtype of <span class="math inline">\(A \times B\)</span>, which is also a lower bound of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, and is greater. </span><span class="sentence">This is a contradiction to the definition of greatest lower bound, meaning that our assumption was wrong. </span><span class="sentence">Hence, the intersection of any given types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is always the greatest lower bound of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>.</span></p>
</div>
</blockquote>
<ul>
<li><div class="TODO">
<span class="sentence">TODO(maybe throw out the whole concept of <span class="math inline">\(\times\)</span> and just make that the GLB?)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(relation between LUB and GLB in contravariant cases)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(again, what to do with equivalent types?)</span>
</div></li>
</ul>
<h3 id="references">References</h3>
<ol type="1">
<li><span class="sentence">Tate, Ross. </span><span class="sentence">â€œMixed-site variance.â€ FOOL, 2013.</span></li>
</ol>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(the big TODO for the whole chapter: we need to clearly decide what kind of type system we want to specify: an algo-driven ts vs a full declarational ts, operation-based or relation-based. </span><span class="sentence">An example of the second distinction would be difference between <span class="math inline">\((A?)!!\)</span> and <span class="math inline">\(((A!!)?)!!\)</span>. </span><span class="sentence">Are they the same type? </span><span class="sentence">Are they different, but equivalent? </span><span class="sentence">Same goes for <span class="math inline">\((A..B)?\)</span> vs <span class="math inline">\((A?..B?)\)</span> and such.)</span></p>
</div>
</div>
<h2 id="built-in-classifier-types">Built-in classifier types</h2>
<ul>
<li><div class="TODO">
<span class="sentence">TODO: Move the whole section to type system?</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO: Move <code>kotlin.Unit</code> here?</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO: <code>Appendable</code>/<code>StringBuilder</code>? </span><span class="sentence">depends on how we plan to approach the interpolation expansion</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO: <code>{Builtin}Array</code> types?</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">As well as the types defined in the <a href="#built-in-types">type system section</a>, Kotlin defines several built-in classifier types that are important for the rest of this document. </span><span class="sentence">These have their own declarations in the standard library, but have special semantics in Kotlin.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this is not meant to declare all the types available in the standard library, for this please refer to the standard library documentation <span><span class="TODO">(TODO: link?)</span><span class="TODO-marker">*</span></span>.</span></p>
</div>
</blockquote>
<h3 id="kotlin.boolean"><code>kotlin.Boolean</code></h3>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Boolean</code> is the boolean logic type of Kotlin, representing the value that may be either <code>true</code> or <code>false</code>. </span><span class="sentence">It is the type of <a href="#boolean-literals">boolean literals</a> as well as the type returned or expected by some built-in Kotlin operators. </span><span class="sentence">For other traits of this type (such as the classes it inherits from, interfaces it may inherit from and its member functions) please refer to the standard library specification.</span></p>
</div>
<h3 id="built-in-integer-types">Built-in integer types</h3>
<div class="paragraph">
<p><span class="sentence">There are several built-in class types that represent signed integer numbers of different bit size. </span><span class="sentence">Unlike some other languages, Kotlin does not have a built-in infinite-length integer number class. </span><span class="sentence">Kotlin also does not currently define any built-in unsigned integer number types. </span><span class="sentence">The signed integer number types are:</span></p>
</div>
<ul>
<li><span class="sentence"><code>kotlin.Int</code></span></li>
<li><span class="sentence"><code>kotlin.Short</code></span></li>
<li><span class="sentence"><code>kotlin.Byte</code></span></li>
<li><span class="sentence"><code>kotlin.Long</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">These types may or may not have different runtime representation. </span><span class="sentence">See your platform reference for details.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Int</code> is the type of integer numbers that is required to be able to hold at least the values in the range from <span class="math inline">\(-2^31\)</span> to <span class="math inline">\(2^31 - 1\)</span>. </span><span class="sentence">If an arithmetic operation on <code>kotlin.Int</code> results in arithmetic overflow or underflow, the result is undefined.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Short</code> is the type of integer numbers that is required to be able to hold at least the values in the range from <span class="math inline">\(-2^15\)</span> to <span class="math inline">\(2^15 - 1\)</span>. </span><span class="sentence">If an arithmetic operation on <code>kotlin.Short</code> results in arithmetic overflow or underflow, the result is undefined.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Byte</code> is the type of integer numbers that is required to be able to hold at least the values in the range from <span class="math inline">\(-2^7\)</span> to <span class="math inline">\(2^7 - 1\)</span>. </span><span class="sentence">If an arithmetic operation on <code>kotlin.Byte</code> results in arithmetic overflow or underflow, the result is undefined.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Long</code> is the type of integer numbers that is required to be able to hold at least the values in the range from <span class="math inline">\(-2^63\)</span> to <span class="math inline">\(2^63 - 1\)</span>. </span><span class="sentence">If an arithmetic operation on <code>kotlin.Long</code> results in arithmetic overflow or underflow, the result is undefined.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For other traits of these types (such as the classes they inherit from, interfaces they may inherit from and their member functions) please refer to the standard library specification.</span></p>
</div>
<h3 id="built-in-floating-point-arithmetic-types">Built-in floating point arithmetic types</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: FP semantics are pretty hard, how much of that we want to put here?</span></p>
</div>
</div>
<h3 id="kotlin.char"><code>kotlin.Char</code></h3>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Char</code> is the built-in class type that represents a single unicode symbol in UTF-16 <span><span class="TODO">(TODO: link)</span><span class="TODO-marker">*</span></span> character encoding. </span><span class="sentence">It is the type of <a href="#character-literals">character literals</a>. </span><span class="sentence">For other traits of this type (such as the classes it inherits from, interfaces it may inherit from and its member functions) please refer to the standard library specification.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: UTF-16 or UCS-2?</span></p>
</div>
</div>
<h3 id="kotlin.string"><code>kotlin.String</code></h3>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.String</code> is the built-in class type that represents a sequence of unicode symbol in UTF-16 <span><span class="TODO">(TODO: link)</span><span class="TODO-marker">*</span></span> character encoding. </span><span class="sentence">It is the type of the result of <a href="#string-interpolation-expressions">string interpolation</a>. </span><span class="sentence">For other traits of this type (such as the classes it inherits from, interfaces it may inherit from and its member functions) please refer to the standard library specification.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: UTF-16 or UCS-2?</span></p>
</div>
</div>
<h2 id="runtime-type-information">Runtime type information</h2>
<div class="paragraph">
<p><span class="sentence">The <em>runtime type information</em> (RTTI) is the information about Kotlin types of values available from these values at runtime. </span><span class="sentence">RTTI affects the semantics of certain expressions, changing their evaluation depending on the amount of RTTI available for particular values, implementation, and platform:</span></p>
</div>
<ul>
<li><span class="sentence"><a href="#type-checking-expression">The type checking operator</a></span></li>
<li><span class="sentence"><a href="#cast-expression">The cast expression</a>, expecially the <code>as?</code> operator</span></li>
<li><span class="sentence">[Class literals][class literal] and the values they evaluate to</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence"><em>Runtime types</em> are particular instances of RTTI for a particular value at runtime. </span><span class="sentence">These model a subset of the Kotlin <a href="#type-system">type system</a>. </span><span class="sentence">Namely, the runtime types are limited to <a href="#classifier-types">classifier types</a>, <a href="#function-types">function types</a> and a special case of <code>kotlin.Nothing?</code> which is the type of <a href="#null-literal"><code>null</code> reference</a> and the only nullable runtime type. </span><span class="sentence">This includes the classifier types created by <a href="#object-literals">anonymous object literals</a>. </span><span class="sentence">There is a slight distinction between a Kotlin type system type and its runtime counterpart:</span></p>
</div>
<ul>
<li><span class="sentence">On some platforms, some particular types may have the same runtime type representation. </span><span class="sentence">This means that checking or casting values of these types works the same way as if they were the same type</span></li>
<li><span class="sentence">Generic types with the same classifier are not required to have different runtime representations. </span><span class="sentence">One cannot generally rely on them having the same representation outside of a particular platform. </span><span class="sentence">Platform specifications must clarify whether some or all types on these platforms have this feature.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">RTTI is also the source of information for platform-specific <em>reflection</em> facilities in the standard library.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The types actual values may have are limited to <a href="#classifier-types">class and object types</a> and <a href="#function-types">function types</a> as well as <code>kotlin.Nothing?</code> for the <code>null</code> reference. </span><span class="sentence"><code>kotlin.Nothing</code> (not to be confused with its nullable variant <code>kotlin.Nothing?</code>) is special in the way that this type is never encountered as a runtime type even though it may have a platform-specific representation. </span><span class="sentence">The reason for this is that this type is used to signify non-existent values.</span></p>
</div>
<h3 id="runtime-available-types">Runtime-available types</h3>
<div class="paragraph">
<p><span class="sentence"><em>Runtime-available types</em> are the types that can be guaranteed (during compilation) to have a concrete <em>runtime</em> counterpart. </span><span class="sentence">These include all the runtime types, their nullable variants as well as [<code>reified</code> type parameters][Reified type parameters], that are guaranteed to inline to a runtime type during type parameter substitution. </span><span class="sentence">Only runtime-available types may be passed (implicitly or explicitly) as substitutions to reified type paramters, used for type checks and safe casts. </span><span class="sentence">During these operations, the nullability of the type is checked using reference-equality to <code>null</code>, while the rest is performed by accessing the runtime type of a value and comparing it to the supplied runtime-available type.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For all generic types that are not expected to have RTTI for their generic arguments, only â€œrawâ€ variants of generic types (denoted in code using the star-projected type notation or a special parameter-less notation <span><span class="TODO">(TODO: link?)</span><span class="TODO-marker">*</span></span>) are runtime-available.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: one may say that classifier generics are <em>partially</em> runtime available due to them having information about only the classifier part of the type</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence"><a href="#exceptions">Exception types</a> must be runtime-available to enable type checks that the <code>catch</code> clause of <a href="#try-expression"><code>try</code>-expression</a> performs.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Only non-nullable runtime types may be used in <code>class</code> literal expressions. </span><span class="sentence">These include reified type parameters with non-nullable upper bounds, as well as all classifier and function types.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Anything else?)</span></p>
</div>
</div>
<h2 id="scopes-and-identifiers">Scopes and identifiers</h2>
<div class="paragraph">
<p><span class="sentence">All the program code in Kotlin is logically divided into <em>scopes</em>. </span><span class="sentence">A scope is a syntactically-delimited region of code that constitutes a context in which entities and their names can be introduced. </span><span class="sentence">Scopes are nested, with entities introduced in outer scopes also available in the inner scopes. </span><span class="sentence">The top level of a Kotlin file is also a scope, containing all the scopes within the file.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">All the scopes are divided into two categories: declaration scopes and statement scopes. </span><span class="sentence">These two kinds of scopes differ in how the identifiers in code refer to the values definied in the scopes.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Declaration scopes include:</span></p>
</div>
<ul>
<li><span class="sentence">The top level scope of a normal Kotlin file (not script file);</span></li>
<li><span class="sentence">The bodies of <a href="#classifier-declaration">classifier declarations</a>;</span></li>
<li><span class="sentence">The bodies of [object literals][Object literal];</span></li>
<li><div class="TODO">
<span class="sentence">TODO(Anything else?)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Statement scopes include:</span></p>
</div>
<ul>
<li><span class="sentence">The top level scope of a Kotlin script file;</span></li>
<li><span class="sentence">Various scopes produced by control structure bodies of different <a href="#expressions">expressions</a>;</span></li>
<li><span class="sentence">The bodies of <a href="#function-declaration">function declarations</a>;</span></li>
<li><span class="sentence">The bodies of <a href="#anonymous-function-declarations">anonymous function literals</a>;</span></li>
<li><span class="sentence">The bodies of getters and setters of <a href="#property-declaration">properties</a>;</span></li>
<li><span class="sentence">The bodies of <a href="#constructor-declaration">constructors</a>;</span></li>
<li><span class="sentence">The bodies of instance initialization blocks in <a href="#class-declaration">class declarations</a>;</span></li>
<li><div class="TODO">
<span class="sentence">TODO(Anything else?)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">All the declarations in a particular scope introduce new <em>bindings</em> of identifiers in this scope to their respective entities in the program. </span><span class="sentence">These entities may be types or values, where values may refer to objects, functions or properties (that may be delegated). </span><span class="sentence">Top-level scopes additionally allow to introduce such bindings using <a href="#packages-and-imports"><code>import</code> directive</a> from other top-level scopes.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In most situations, it is not allowed to bind several values to the same identifier in the same scope, but it is allowed to bind a value to an identifier already available in the scope through outer scopes or imports. </span><span class="sentence">An exception to this rule are function declarations, that, in addition to identifier bound to, also may differ by signature <span><span class="TODO">(TODO: whatâ€™s a signature?)</span><span class="TODO-marker">*</span></span> and allow definining several functions with the same name in the same scope. </span><span class="sentence">When <a href="#call-and-property-access-expressions">calling functions</a> a process called <a href="#overload-resolution">overloading resolution</a> takes places that allows differentiating such functions. </span><span class="sentence">Overloading resolution also applies to properties if they are used as functions through <code>invoke</code>-convention, but it does not mean several properties with the same name may be defined in the same scope.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The main difference between declaration scopes and statement scopes is that names in the statement scope are bound in the order their declarations appear in it. </span><span class="sentence">It is not allowed to access a value through an identifier in the code that (syntactically) precedes the binding itself. </span><span class="sentence">On the contrary, in declaration scopes it is fully allowed, although initialization cycles may occur and need to be detected by the compiler. </span><span class="sentence">It also means that the statement scopes nested inside declaration scopes may access values declared after itself in the declaration scopes, but any values defined inside the statement scope must be accessed only after they are declared.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<ul>
<li><div class="paragraph">
<p><span class="sentence">In declaration scope:</span></p>
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb1-1" data-line-number="1">    <span class="co">// x refers to the property defined below even if there is another property</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="co">// called x in outer scope or imported</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="kw">fun</span> <span class="fu">foo</span>() { <span class="kw">return</span> x + <span class="dv">2</span>; } </a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="kw">val</span> <span class="va">x</span> = <span class="dv">3</span>; </a></code></pre></div></li>
<li><div class="paragraph">
<p><span class="sentence">In statement scope:</span></p>
</div>
<div class="sourceCode" id="cb2"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb2-1" data-line-number="1">    <span class="co">// x either refers to other property defined in some outer scope or imported</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="co">// or it is a compile-time error</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="kw">fun</span> <span class="fu">foo</span>() { <span class="kw">return</span> x + <span class="dv">2</span>; } </a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    <span class="kw">val</span> <span class="va">x</span> = <span class="dv">3</span>; </a></code></pre></div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: please note that all the above is primarily applied to declarations, because declaration scopes do not allow standalone statements to appear in them</span></p>
</div>
</blockquote>
<ul>
<li><div class="TODO">
<span class="sentence">TODO(qualified names?)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(extensions?)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(receivers)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(rewrite expressions and statements as references to this part)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(identifier lifetime &amp; such)</span>
</div></li>
</ul>
<h2 id="packages-and-imports">Packages and imports</h2>
<div class="paragraph">
<p><span class="sentence">Any Kotlin project is structured into <strong>packages</strong>. </span><span class="sentence">A package may contain one or more Kotlin files and each file is related to the corresponding package using the <em>package header</em>. </span><span class="sentence">A file may contain only one (or zero) package headers, meaning that each file belongs to exactly one package.</span></p>
</div>
<div id="grammar-rule-packageHeader-pasted-0" class="grammar-rule">
<dl>
<dt><strong><em>packageHeader</em>:</strong></dt>
<dd><span class="sentence"><code>'package'</code> <em><a href="#grammar-rule-identifier">identifier</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>]</span>
</dd>
</dl>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: an absence of a package header in a file means that is belongs to the special <em>root package</em></span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: Packages are different from <a href="#modules">modules</a>. </span><span class="sentence">A module may contain many packages, while a single package can be spread across several modules.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The name of a package is a dot (<code>.</code>)-separated sequence of identifiers, introducing a package hierarchy. </span><span class="sentence">Unlike Java and some other languages, Kotlin does not restrict the package hierarchy to correspond directly to the folder structure of the project.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means that the hierarchy itself is only notational, not affecting the code in any way. </span><span class="sentence">It is strongly recommended, however, that the folder structure of the project does correspond to the package hierarchy.</span></p>
</div>
</blockquote>
<h3 id="importing">Importing</h3>
<div class="paragraph">
<p><span class="sentence">Program entities declared in one package may be freely used in any file in the same package with the only restriction being <a href="#modules">module</a> boundaries. </span><span class="sentence">In order to use an entity from a file belonging to a different package, the programmer must use <em>import directives</em>.</span></p>
</div>
<div id="grammar-rule-importList-pasted-1" class="grammar-rule">
<dl>
<dt><strong><em>importList</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-importHeader">importHeader</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-importHeader-pasted-2" class="grammar-rule">
<dl>
<dt><strong><em>importHeader</em>:</strong></dt>
<dd><span class="sentence"><code>'import'</code> <em><a href="#grammar-rule-identifier">identifier</a></em> [(<code>'.'</code> <code>'*'</code>) | <em><a href="#grammar-rule-importAlias">importAlias</a></em>] [<em><a href="#grammar-rule-semi">semi</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-importAlias-pasted-3" class="grammar-rule">
<dl>
<dt><strong><em>importAlias</em>:</strong></dt>
<dd><span class="sentence"><code>'as'</code> <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An import directive contains dot-separated <em>path</em> to an entity, as well as the name of the entity itself (the last argument of the navigation dot operator). </span><span class="sentence">A path may include not only the package the import is importing from, but also an object or a type (referring to companion object of this type). </span><span class="sentence">Any named declaration within that scope (that is, top-level scope of all files in the package or, in the object case, the object declararion scope) may be imported using their names. </span><span class="sentence">There are two special kinds of imports: star-imports ending in an asterisk (<code>*</code>) and renaming imports employing the use of <code>as</code> operator. </span><span class="sentence">Star-imports import all the named entities inside the corresponding scope, but have weaker priority during <a href="#overload-resolution">resolution</a> of functions and properties. </span><span class="sentence">Renaming imports work just as regular imports, but introduce the entity into current file with a name different from the name it has at declaration site.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Imports are file-based, meaning that if an entity is introduced into file A.kt belonging to package <code>kotlinx.foo</code>, it does not introduce this entity to all other files belonging to <code>kotlinx.foo</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are some packages that have all their entities <em>implicitly imported</em> into any Kotlin file, meaning one can access this entity without explicitly using import directives. </span><span class="sentence">One may, however, import this entities explicitly if they choose to. </span><span class="sentence">These are the following packages of the standard library:</span></p>
</div>
<ul>
<li><span class="sentence"><code>kotlin</code></span></li>
<li><span class="sentence"><code>kotlin.annotation</code></span></li>
<li><span class="sentence"><code>kotlin.collections</code></span></li>
<li><span class="sentence"><code>kotlin.comparisons</code></span></li>
<li><span class="sentence"><code>kotlin.io</code></span></li>
<li><span class="sentence"><code>kotlin.ranges</code></span></li>
<li><span class="sentence"><code>kotlin.sequences</code></span></li>
<li><span class="sentence"><code>kotlin.text</code></span></li>
<li><span class="sentence"><code>kotlin.math</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Platform implementations may introduce additional implicitly imported packages, for example, adding standard platform functionality into Kotlin code.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: an example of this would be <code>java.lang</code> package implicitly imported on the jvm platform</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Importing certain entities may be disallowed by their [visibility modifiers][Visibility].</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Clarify all this)</span></p>
</div>
</div>
<h3 id="modules">Modules</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Here be The dragons)</span></p>
</div>
</div>
<h2 id="overloadable-operators">Overloadable operators</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(rename this and all the refs to smth)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Some syntax forms in Kotlin are defined by convention, meaning that their semantics are defined through syntactic expansion of current syntax form into another syntax form. </span><span class="sentence">The expansion of a particular syntax form is a different piece of code usually defined in the terms of operator functions. </span><span class="sentence">Operator functions are function that are <a href="#function-declaration">declared</a> with a special keyword <code>operator</code> and are not different from normal functions when called normally, but allow themselves to be employed by syntactic expansion. </span><span class="sentence">Different platforms may add other criteria on whether a function may be considered a suitable candidate for operator convention.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Particular cases of definition by convention include:</span></p>
</div>
<ul>
<li><span class="sentence">Arithmetic and comparison operators;</span></li>
<li><span class="sentence">Operator-form <a href="#assignments">assignments</a>;</span></li>
<li><span class="sentence"><a href="#for-loop-statement">For-loop statements</a>;</span></li>
<li><span class="sentence"><a href="#delegated-property-declaration">Delegated properties</a>;</span></li>
<li><div class="TODO">
<span class="sentence">TODO(anything else?)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">There are several common points among all the syntax forms defined using this mechanism:</span></p>
</div>
<ul>
<li><span class="sentence">The expansions are hygenic, meaning that even if they seemingly introduce new identifiers that were not present in original syntax, all such identifiers are not accessible outside the expansion and cannot clash with any other declarations in the program;</span></li>
<li><span class="sentence">All the new call expressions that are produced by expansion are only allowed to use operator functions.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h2 id="declarations">Declarations</h2>
<h3 id="glossary-2">Glossary</h3>
<dl>
<dt>Entity</dt>
<dd><span class="sentence">A distinguishable part of a program</span>
</dd>
<dt>Path</dt>
<dd><span class="sentence">A sequence of names which identifies a program entity</span>
</dd>
</dl>
<h3 id="identifiers-names-and-paths">Identifiers, names and paths</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Explain paths)</span></p>
</div>
</div>
<h3 id="introduction-2">Introduction</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Examples)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Declarations in Kotlin are used to introduce entities (values, types, etc.); most declarations are <em>named</em>, i.e.Â they also assign an identifier to their own entity, however, some declarations may be <em>anonymous</em>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Every declaration is accessible in a particular <em>scope</em>, which is dependent both on where the declaration is located and on the declaration itself.</span></p>
</div>
<h3 id="classifier-declaration">Classifier declaration</h3>
<div id="grammar-rule-classDeclaration-pasted-4" class="grammar-rule">
<dl>
<dt><strong><em>classDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
(<code>'class'</code> | <code>'interface'</code>)<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-primaryConstructor">primaryConstructor</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>) | ({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-enumClassBody">enumClassBody</a></em>)]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-objectDeclaration-pasted-5" class="grammar-rule">
<dl>
<dt><strong><em>objectDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'object'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>]</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Classifier declarations introduce new types to the program, of the forms described <a href="#classifier-types">here</a>. </span><span class="sentence">There are three kinds of classifier declarations:</span></p>
</div>
<ul>
<li><span class="sentence">class declarations</span></li>
<li><span class="sentence">interface declarations</span></li>
<li><span class="sentence">object declarations</span></li>
</ul>
<h4 id="class-declaration">Class declaration</h4>
<div class="paragraph">
<p><span class="sentence">A simple class declaration consists of the following parts.</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(c\)</span></span></li>
<li><span class="sentence">primary constructor declaration <span class="math inline">\(ptor\)</span></span></li>
<li><span class="sentence">supertype specifiers <span class="math inline">\(S_1, \ldots, S_s\)</span></span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span>, which may include the following</span>
<ul>
<li><span class="sentence">secondary constructor declarations <span class="math inline">\(stor_1, \ldots, stor_c\)</span></span></li>
<li><span class="sentence">instance initialization block <span class="math inline">\(init\)</span></span></li>
<li><span class="sentence">property declarations <span class="math inline">\(prop_1, \ldots, prop_p\)</span></span></li>
<li><span class="sentence">function declarations <span class="math inline">\(md_1, \ldots, md_m\)</span></span></li>
<li><span class="sentence">companion object declaration <span class="math inline">\(companionObj\)</span></span></li>
<li><span class="sentence">nested classifier declarations <span class="math inline">\(nested\)</span></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and creates a simple classifier type <span class="math inline">\(c : S_1, \ldots, S_s\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Supertype specifiers are used to create inheritance relation between the declared type and the specified supertype. </span><span class="sentence">You can use classes and interfaces as supertypes, but not objects.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It is allowed to inherit from a single class only, i.e., multiple class inheritance is not supported. </span><span class="sentence">Multiple interface inheritance is allowed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Instance initialization block describes a block of code which should be executed during <a href="#classifier-initialization">object creation</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Property and function declarations in the class body introduce their respective entities in this classâ€™ scope, meaning they are available only on an entity of the corresponding class.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Companion object declaration <code>companion object CO { ... }</code> for class <code>C</code> introduces an object, which is available under this classâ€™ name or under the path <code>C.CO</code>. </span><span class="sentence">Companion object name may be omitted, in which case it is considered to be equal to <code>Companion</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Nested classifier declarations introduce new classifiers, available under this classâ€™ path for all nested classifiers except for inner classes. </span><span class="sentence">Inner classes are available only on the corresponding classâ€™ entities. </span><span class="sentence">Further details are available [here][Inner and nested classes].</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Examples)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">A parameterized class declaration consists of the following parts.</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(c\)</span></span></li>
<li><span class="sentence">type parameter list <span class="math inline">\(T_1, \ldots, T_m\)</span></span></li>
<li><span class="sentence">primary constructor declaration <span class="math inline">\(ptor\)</span></span></li>
<li><span class="sentence">supertype specifiers <span class="math inline">\(S_1, \ldots, S_s\)</span></span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span>, which may include the following</span>
<ul>
<li><span class="sentence">secondary constructor declarations <span class="math inline">\(stor_1, \ldots, stor_c\)</span></span></li>
<li><span class="sentence">instance initialization block <span class="math inline">\(init\)</span></span></li>
<li><span class="sentence">property declarations <span class="math inline">\(prop_1, \ldots, prop_p\)</span></span></li>
<li><span class="sentence">function declarations <span class="math inline">\(md_1, \ldots, md_m\)</span></span></li>
<li><span class="sentence">companion object declaration <span class="math inline">\(companionObj\)</span></span></li>
<li><span class="sentence">nested classifier declarations <span class="math inline">\(nested\)</span></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and extends the rules for a simple class declaration w.r.t. type parameter list. </span><span class="sentence">Further details are described <a href="#declarations-with-type-parameters">here</a>.</span></p>
</div>
<h5 id="constructor-declaration">Constructor declaration</h5>
<div class="paragraph">
<p><span class="sentence">There are two types of class constructors in Kotlin: primary and secondary.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A primary constructor is a concise way of describing class properties together with constructor parameters, and has the following form</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[ptor : (p_1, \ldots, p_n)\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">where each of <span class="math inline">\(p_i\)</span> may be one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">regular constructor parameter <span class="math inline">\(name: type\)</span></span></li>
<li><span class="sentence">read-only property constructor parameter <span class="math inline">\(val name: type\)</span></span></li>
<li><span class="sentence">mutable property constructor parameter <span class="math inline">\(var name: type\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Property constructor parameters, together with being regular constructor parameters, also declare class properties of the same name and type. </span><span class="sentence">One can consider them to have the following syntactic expansion.</span></p>
</div>
<div class="sourceCode" id="cb3"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">class</span> Foo(<span class="va">i</span>: <span class="dt">Int</span>, <span class="kw">val</span> <span class="va">d</span>: <span class="dt">Double</span>, <span class="kw">var</span> <span class="va">s</span>: <span class="dt">String</span>) : <span class="dt">Super</span>(<span class="va">i</span>, <span class="va">d</span>, <span class="va">s</span>) {}</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">class</span> Foo(<span class="va">i</span>: <span class="dt">Int</span>, <span class="va">d_</span>: <span class="dt">Double</span>, <span class="va">s_</span>: <span class="dt">String</span>) : <span class="dt">Super</span>(<span class="va">i</span>, <span class="va">d_</span>, <span class="va">s_</span>) {</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="kw">val</span> <span class="va">d</span> = d_</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  <span class="kw">var</span> <span class="va">s</span> = s_</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">When accessing property constructor parameters inside the class body, one works with their corresponding properties; however, when accessing them in the supertype specifier list (e.g., as an argument to a superclass constructor invocation), we see them as actual parameters, which cannot be changed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a class declaration has a primary constructor and also includes a class supertype specifier, that specifier must represent a valid invocation of the supertype constructor.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A secondary constructor describes an alternative way of creating a class instance and has only regular constructor parameters. </span><span class="sentence">If a class has a primary constructor, any secondary constructor must delegate to either the primary constructor or to another secondary constructor via <code>this(...)</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a class does not have a primary constructor, its secondary constructors must delegate to either the superclass constructor via <code>super(...)</code> (if the superclass is present in the supertype specifier list) or to another secondary constructor via <code>this(...)</code>. </span><span class="sentence">If the only superclass is <code>Any</code>, delegation is optional.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In all cases, it is forbidden if two or more secondary constructors form a delegation loop.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(elaborate this <code>this(...)</code> and <code>super(...)</code> business)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(default values in constructors???)</span></p>
</div>
</div>
<h5 id="nested-and-inner-classifiers">Nested and inner classifiers</h5>
<div class="paragraph">
<p><span class="sentence">If a classifier declaration <span class="math inline">\(ND\)</span> is <em>nested</em> in another classifier declaration <span class="math inline">\(PD\)</span>, it creates a nested classifier type â€” a classifier type available under the path <span class="math inline">\(PD.ND\)</span>. </span><span class="sentence">In all other aspects, nested classifiers are equivalent to regular ones.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Inner classes are a special kind of nested classifiers, which introduce types of objects associated (linked) with other (parent) objects. </span><span class="sentence">An inner class declaration <span class="math inline">\(ID\)</span> nested in another classifier declaration <span class="math inline">\(PD\)</span> may reference an <em>object</em> of type <span class="math inline">\(ID\)</span> associated with it.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">This association happens when instantiating an object of type <span class="math inline">\(ID\)</span>, as its constructor may be invoked only when a receiver of type <span class="math inline">\(PD\)</span> is available, and this receiver becomes associated with the new instantiated object of type <span class="math inline">\(ID\)</span>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(â€¦)</span></p>
</div>
</div>
<h5 id="inheritance-delegation">Inheritance delegation</h5>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(â€¦)</span></p>
</div>
</div>
<h4 id="data-class-declaration">Data class declaration</h4>
<div class="paragraph">
<p><span class="sentence">A data class <span class="math inline">\(dataClass\)</span> is a special kind of class, which represents a product type constructed from a number of data properties <span class="math inline">\((dp_1, \ldots, dp_m)\)</span>, described in its primary constructor. </span><span class="sentence">As such, it allows Kotlin to reduce the boilerplate and generate a number of additional data-relevant functions.</span></p>
</div>
<ul>
<li><span class="sentence"><code>equals() / hashCode() / toString()</code> functions compliant with their contracts</span>
<ul>
<li><div class="TODO">
<span class="sentence">TODO(Nope, we should explicitly specify the contracts here, especially for <code>toString</code>)</span>
</div></li>
</ul></li>
<li><span class="sentence">A <code>copy()</code> function for shallow object copying</span></li>
<li><span class="sentence">A number of <code>componentN()</code> functions for destructive declaration</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Some of these may be overriden, some cannot)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">All these functions consider only data properties <span class="math inline">\(\{dp_i\}\)</span>; e.g., your data class may include regular property declarations in its body, however, they will <em>not</em> be considered in the <code>equals()</code> implementation or have a <code>componentN()</code> generated for them.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To support these features, data classes have the following restrictions.</span></p>
</div>
<ul>
<li><span class="sentence">Data classes are final and cannot be inherited from</span></li>
<li><span class="sentence">Data classes must have a primary constructor with only property constructor parameters, which become data properties for the data class</span></li>
</ul>
<h5 id="data-class-generation">Data class generation</h5>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(A more detailed explaination)</span></p>
</div>
</div>
<h4 id="enum-class-declaration">Enum class declaration</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(â€¦)</span></p>
</div>
</div>
<h4 id="annotation-class-declaration">Annotation class declaration</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(â€¦)</span></p>
</div>
</div>
<h4 id="interface-declaration">Interface declaration</h4>
<div class="paragraph">
<p><span class="sentence">Interfaces differ from classes in that they cannot be directly instantiated in the program, they are meant as a way of describing a contract which should be satisfied by the interfaceâ€™s subtypes. </span><span class="sentence">In other aspects they are similar to classes, therefore we shall specify their declarations by specifying their differences from class declarations.</span></p>
</div>
<ul>
<li><span class="sentence">An interface cannot have a class as its supertype</span></li>
<li><span class="sentence">An interface cannot have a constructor</span></li>
<li><span class="sentence">Interface properties cannot have initializers or backing fields</span></li>
<li><span class="sentence">An interface cannot have inner classes (but can have nested classes and companion objects)</span></li>
<li><span class="sentence">An interface and all its members are implicitly open</span></li>
<li><span class="sentence">All interface member properties and functions are implicitly public</span>
<ul>
<li><span class="sentence">Trying to declare a non-public member property or function in an interface is an error</span></li>
</ul></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Something else?)</span></p>
</div>
</div>
<h4 id="object-declaration">Object declaration</h4>
<div class="paragraph">
<p><span class="sentence">Object declarations are used to support a singleton pattern and, thus, do two things at the same time. </span><span class="sentence">One, they (just like class declarations) introduce a new type to the program. </span><span class="sentence">Two, they create a singleton-like object of that type.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(do we really need this ironic-ish statement about doing two things at the same time?)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Similarly to interfaces, we shall specify object declarations by highlighting their differences from class declarations.</span></p>
</div>
<ul>
<li><span class="sentence">An object type cannot be used as a supertype for other types</span></li>
<li><span class="sentence">An object cannot have a constructor</span></li>
<li><span class="sentence">An object cannot have a companion object</span></li>
<li><span class="sentence">An object may not have inner classes</span></li>
<li><span class="sentence">An object cannot be parameterized, i.e., cannot have type parameters</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Something else?)</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this section is about declaration of <em>named</em> objects. </span><span class="sentence">Kotlin also has a concept of <em>anonymous</em> objects, or object literals, which are similar to their named counterparts, but are expressions rather than declarations and, as such, are described in the <a href="#object-literals">corresponding section</a>.</span></p>
</div>
</blockquote>
<h4 id="classifier-initialization">Classifier initialization</h4>
<div class="paragraph">
<p><span class="sentence">When creating a class or object instance via one of its constructors <span class="math inline">\(ctor\)</span>, it is initialized in a particular order, which we describe here.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">First, a supertype constructor corresponding to <span class="math inline">\(ctor\)</span> is called with its respective parameters.</span></p>
</div>
<ul>
<li><span class="sentence">If <span class="math inline">\(ctor\)</span> is a primary constructor, a corresponding supertype constructor is the one from the supertype specifier list</span></li>
<li><span class="sentence">If <span class="math inline">\(ctor\)</span> is a secondary constructor, a corresponding supertype constructor is the one ending the constructor delegation chain of <span class="math inline">\(ctor\)</span></span></li>
<li><span class="sentence">If an explicit supertype constructor is not available, <code>Any()</code> is implicitly used</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">After the supertype initialization is done, we continue the initialization by processing each inner declaration in its body, <em>in the order of their inclusion in the body</em>. </span><span class="sentence">If any initialization step creates a loop, it is considered an undefined behavior.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Need to define order between supertype constructor, primary constructor, init blocks and secondary constructors)</span></p>
</div>
</div>
<h3 id="function-declaration">Function declaration</h3>
<div id="grammar-rule-functionDeclaration-pasted-6" class="grammar-rule">
<dl>
<dt><strong><em>functionDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<em><a href="#grammar-rule-functionHeader">functionHeader</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-functionValueParameters">functionValueParameters</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionBody">functionBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionBody-pasted-7" class="grammar-rule">
<dl>
<dt><strong><em>functionBody</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-block">block</a></em><br />
| (<code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Function declarations assign names to functions â€” blocks of code which may be called by passing them a number of arguments. </span><span class="sentence">Functions have special <em>function types</em> which are covered in more detail <a href="#function-types">here</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A simple function declaration consists of four main parts:</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(f\)</span></span></li>
<li><span class="sentence">parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span></span></li>
<li><span class="sentence">return type <span class="math inline">\(R\)</span></span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and creates a function type <span class="math inline">\(f : (P_1, \ldots, P_n) \rightarrow R\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span> describes function parameters â€” inputs needed to execute the declared function. </span><span class="sentence">Each parameter <span class="math inline">\(p_i: P_i = v_i\)</span> introduces <span class="math inline">\(p_i\)</span> as a name of value with type <span class="math inline">\(P_i\)</span> available inside function body <span class="math inline">\(b\)</span>; therefore, parameters are final and cannot be changed inside the function. </span><span class="sentence">A function may have zero or more parameters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A parameter may include a default value <span class="math inline">\(v_i\)</span>, which is used if the corresponding argument is not specified in function invocation; <span class="math inline">\(v_i\)</span> should be an expression which evaluates to type <span class="math inline">\(V &lt;: P_i\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Return type <span class="math inline">\(R\)</span> is optional, if function body <span class="math inline">\(b\)</span> is present and may be inferred to have a valid type <span class="math inline">\(B : B \not \equiv kotlin.Nothing\)</span>, in which case <span class="math inline">\(R \equiv B\)</span>. </span><span class="sentence">In other cases return type <span class="math inline">\(R\)</span> must be specified explicitly.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">As type <span class="math inline">\(kotlin.Nothing\)</span> has a <a href="#kotlin.nothing">special meaning</a> in Kotlin type system, it must be specified explicitly, to avoid spurious <span class="math inline">\(kotlin.Nothing\)</span> function return types.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Function body <span class="math inline">\(b\)</span> is optional; if it is ommited, a function declaration creates an <em>abstract</em> function, which does not have an implementation. </span><span class="sentence">This is allowed only inside an <a href="#classifier-declaration">abstract classifier declaration</a>. </span><span class="sentence">If a function body <span class="math inline">\(b\)</span> is present, it should evaluate to type <span class="math inline">\(B\)</span> which should satisfy <span class="math inline">\(B &lt;: R\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A parameterized function declaration consists of five main parts.</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(f\)</span></span></li>
<li><span class="sentence">type parameter list <span class="math inline">\(T_1, \ldots, T_m\)</span></span></li>
<li><span class="sentence">parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span></span></li>
<li><span class="sentence">return type <span class="math inline">\(R\)</span></span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and extends the rules for a simple function declaration w.r.t. type parameter list. </span><span class="sentence">Further details are described <a href="#declarations-with-type-parameters">here</a>.</span></p>
</div>
<h4 id="named-positional-and-default-parameters">Named, positional and default parameters</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin supports <em>named</em> parameters out-of-the-box, meaning one can bind an argument to a parameter in function invocation not by its position, but by its name, which is equal to the argument name.</span></p>
</div>
<div class="sourceCode" id="cb4"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">fun</span> <span class="fu">bar</span>(<span class="va">a</span>: <span class="dt">Int</span>, <span class="va">b</span>: <span class="dt">Double</span>, <span class="va">s</span>: <span class="dt">String</span>): <span class="dt">Double</span> = a + b + s.toDouble()</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    println(bar(b = <span class="fl">42.0</span>, a = <span class="dv">5</span>, s = <span class="st">&quot;13&quot;</span>))</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">}</a></code></pre></div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Argument names are resolved in compile time)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">If one wants to mix named and positional arguments, the argument list must conform to the following form: <span class="math inline">\(P_1, \ldots, P_M, N_1, \ldots, N_Q\)</span>, where <span class="math inline">\(P_i\)</span> is a positional argument, <span class="math inline">\(N_j\)</span> is a named argument; i.e., positional arguments must precede all of the named ones.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Kotlin also supports <em>default</em> parameters â€” parameters which have a default value used in function invocation, if the corresponding argument is missing. </span><span class="sentence">Note that default parameters cannot be used to provide a value for positional argument <em>in the middle</em> of the positional argument list; allowing this would create an ambiguity of which argument for position <span class="math inline">\(i\)</span> is the correct one: explicit one provided by the developer or implicit one from the default value.</span></p>
</div>
<div class="sourceCode" id="cb5"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">fun</span> <span class="fu">bar</span>(<span class="va">a</span>: <span class="dt">Int</span> = 1, <span class="va">b</span>: <span class="dt">Double</span> = 42.0, <span class="va">s</span>: <span class="dt">String</span> = <span class="st">&quot;Hello&quot;</span>): <span class="dt">Double</span> =</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    a + b + s.toDouble()</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    <span class="co">// Valid call, all default parameters used</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    println(bar())</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    <span class="co">// Valid call, defaults for `b` and `s` used</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    println(bar(<span class="dv">2</span>))</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    <span class="co">// Valid call, default for `b` used</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    println(bar(<span class="dv">2</span>, s = <span class="st">&quot;Me&quot;</span>))</a>
<a class="sourceLine" id="cb5-11" data-line-number="11"></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    <span class="co">// Invalid call, default for `b` cannot be used</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    println(bar(<span class="dv">2</span>, <span class="st">&quot;Me&quot;</span>))</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">In summary, argument list should have the following form:</span></p>
</div>
<ul>
<li><span class="sentence">Zero or more positional arguments</span></li>
<li><span class="sentence">Zero or more named arguments</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Missing arguments are bound to their default values, if they exist.</span></p>
</div>
<h4 id="variable-length-parameters">Variable length parameters</h4>
<div class="paragraph">
<p><span class="sentence">One of the parameters may be designated as being variable length (aka <em>vararg</em>). </span><span class="sentence">A parameter list <span class="math inline">\((p_1, \ldots, \text{vararg }p_i: P_i = v_i, \ldots, p_n)\)</span> means a function may be called with any number of arguments in the i-th position. </span><span class="sentence">These arguments are represented inside function body <span class="math inline">\(b\)</span> as an <a href="#array-types">array of type <span class="math inline">\(P_i\)</span></a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a variable length parameter is not last in the parameter list, all subsequent arguments in the function invocation should be specified as named arguments. </span><span class="sentence">If a variable length parameter has a default value, it should be an expression which evaluates to an <a href="#array-types">array of type <span class="math inline">\(P_i\)</span></a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An array of type <span class="math inline">\(Q &lt;: P_i\)</span> may be <em>unpacked</em> to a variable length parameter in function invocation using [spread operator][Spread operator]; in this case array elements are considered to be separate arguments in the variable length parameter position. </span><span class="sentence">A function invocation may include several spread operator expressions corresponding to the vararg parameter.</span></p>
</div>
<h4 id="extension-function-declaration">Extension function declaration</h4>
<div class="paragraph">
<p><span class="sentence">An <em>extension function declaration</em> is similar to a standard function declaration, but introduces an additional special function parameter, the <em>receiver parameter</em>. </span><span class="sentence">This parameter is designated by specifying the receiver type (the type before <code>.</code> in function name), which becomes the type of this receiver parameter. </span><span class="sentence">This parameter is not named and must always be supplied, e.g.Â it cannot be a variable-argument parameter, have a default value, etc.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Calling such a function is special because the receiver parameter is not supplied as an argument of the call, but as the <a href="#receivers"><em>receiver</em></a> of the call, be it implicit or explicit. </span><span class="sentence">This parameter is available inside the scope of the function as the implicit receiver or <code>this</code>-expression, while nested scopes may introduce additional receivers that take precedence over this one. </span><span class="sentence">See <a href="#receivers">the receiver section</a> for details. </span><span class="sentence">This receiver is also available (as usual) in nested scope using labeled <code>this</code> syntax using the name of the declared function as the label.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For more information on how a particular receiver for each call is chosen, please refer to the <a href="#overload-resolution">overloading section</a>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: when declaring extension functions inside classifier declarations, this receiver takes precedence over the classifier object, which is usually the current receiver inside nested functions</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">For all other purposes, extension functions are not different from non-extension functions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Examples:</span></p>
</div>
<div class="sourceCode" id="cb6"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">fun</span> <span class="fu">Int</span>.<span class="fu">foo</span>() { println(<span class="kw">this</span> + <span class="dv">1</span>) } <span class="co">// this has type Int</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="fl">2.f</span>oo() <span class="co">// prints &quot;3&quot;</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">class</span> Bar {</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">    <span class="kw">fun</span> <span class="fu">foo</span>() { println(<span class="kw">this</span>) } <span class="co">// this has type Bar</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    <span class="kw">fun</span> <span class="fu">Int</span>.<span class="fu">foo</span>() { println(<span class="kw">this</span>) } <span class="co">// this has type Int</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">}</a></code></pre></div>
<h3 id="property-declaration">Property declaration</h3>
<div id="grammar-rule-propertyDeclaration-pasted-8" class="grammar-rule">
<dl>
<dt><strong><em>propertyDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
(<code>'val'</code> | <code>'var'</code>)<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-receiverType">receiverType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
({<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em> | <em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em>))<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} ((<code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>) | <em><a href="#grammar-rule-propertyDelegate">propertyDelegate</a></em>)]<br />
[(<em><a href="#grammar-rule-NL">NL</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>}) <code>';'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
(([<em><a href="#grammar-rule-getter">getter</a></em>] [{<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-semi">semi</a></em>] <em><a href="#grammar-rule-setter">setter</a></em>]) | ([<em><a href="#grammar-rule-setter">setter</a></em>] [{<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-semi">semi</a></em>] <em><a href="#grammar-rule-getter">getter</a></em>]))</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Property declarations are used to create read-only (<code>val</code>) or mutable (<code>var</code>) entities in their respective scope. </span><span class="sentence">Properties may also have custom getter or setter â€” functions which are used to read or write the property value.</span></p>
</div>
<h4 id="read-only-property-declaration">Read-only property declaration</h4>
<div class="paragraph">
<p><span class="sentence">A read-only property declaration <code>val x: T = e</code> introduces <code>x</code> as a name of the result of <code>e</code>. </span><span class="sentence">Both the right-hand value <code>e</code> and the type <code>T</code> are optional, however, at least one of them must be specified. </span><span class="sentence">More so, if the type of <code>e</code> cannot be <a href="#type-inference">inferred</a>, the type <code>T</code> must be specified explicitly. </span><span class="sentence">In case both are specified, the type of <code>e</code> must be a subtype of <code>T</code> (see <a href="#subtyping">subtyping</a> for more details).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A read-only property declaration may include a custom <a href="#getters-and-setters">getter</a> in the form of</span></p>
</div>
<div class="sourceCode" id="cb7"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">val</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="kw">get</span>() { ... }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">in which case <code>x</code> is used as a synonym to the getter invocation.</span></p>
</div>
<h4 id="mutable-property-declaration">Mutable property declaration</h4>
<div class="paragraph">
<p><span class="sentence">A mutable property declaration <code>var x: T = e</code> introduces <code>x</code> as a name of a mutable variable with type <code>T</code> and initial value equals to the result of <code>e</code>. </span><span class="sentence">The rules regarding the right-hand value <code>e</code> and the type <code>T</code> match those of a read-only property declaration.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A mutable property declaration may include a custom <a href="#getters-and-setters">getter</a> and/or custom <a href="#getters-and-setters">setter</a> in the form of</span></p>
</div>
<div class="sourceCode" id="cb8"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    <span class="kw">get</span>(): TG { ... }</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    <span class="kw">set</span>(value: TS) { ... }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">in which case <code>x</code> is used as a synonym to the getter invocation when read from and to the setter invocation when written to.</span></p>
</div>
<h4 id="delegated-property-declaration">Delegated property declaration</h4>
<div class="paragraph">
<p><span class="sentence">A delegated read-only property declaration <code>val x: T by e</code> introduces <code>x</code> as a name for the <em>delegation</em> result of property <code>x</code> to the entity <code>e</code>. </span><span class="sentence">One may view these properties as regular properties with a special <em>delegating</em> <a href="#getters-and-setters">getters</a>. </span><span class="sentence">TODO(Type is optional if inferred?)</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In case of a delegated read-only property, access to <code>x</code> is replaced with the call to a special function <code>getValue</code>, which must be available on <code>e</code>. </span><span class="sentence">This function has the following signature</span></p>
</div>
<div class="sourceCode" id="cb9"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">getValue</span>(<span class="va">thisRef</span>: <span class="dt">E</span>, <span class="va">property</span>: <span class="dt">PropertyInfo</span>): <span class="dt">R</span></a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where</span></p>
</div>
<ul>
<li><span class="sentence"><code>thisRef: E</code> is the reference to the enclosing entity</span>
<ul>
<li><span class="sentence">holds the enclosing class or object instance in case of classifier property</span></li>
<li><span class="sentence">is <code>null</code> for <a href="#local-property-declaration">local properties</a></span></li>
</ul></li>
<li><span class="sentence"><code>property: PropertyInfo</code> contains runtime-available information about the declared property, most importantly</span>
<ul>
<li><span class="sentence"><code>property.name</code> holds the property name</span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This convention implies the following requirements on the <code>getValue</code> function</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(S &lt;: E\)</span>, where <span class="math inline">\(S\)</span> is the type of the enclosing entity</span></li>
<li><span class="sentence"><span class="math inline">\(\text{KProperty&lt;*&gt;} &lt;: \text{PropertyInfo}\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(R\)</span> should be in a supertype relation with the delegated property type <span class="math inline">\(T\)</span></span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">In case of the local property, enclosing entity has the type <code>Nothing?</code></span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A delegated mutable property declaration <code>var x: T by e</code> introduces <code>x</code> as a name of a mutable entity with type <code>T</code>, access to which is <em>delegated</em> to the entity <code>e</code>. </span><span class="sentence">As before, one may view these properties as regular properties with special <em>delegating</em> <a href="#getters-and-setters">getters and setters</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Read access is handeled using the same <code>getValue</code> function as for a delegated read-only property. </span><span class="sentence">Write access is processed using a special function <code>setValue</code>, which must be available on <code>e</code>. </span><span class="sentence">This function has the following signature</span></p>
</div>
<div class="sourceCode" id="cb10"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">setValue</span>(<span class="va">thisRef</span>: <span class="dt">E</span>, <span class="va">property</span>: <span class="dt">PropertyInfo</span>, <span class="va">value</span>: <span class="dt">R</span>): <span class="dt">U</span></a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where</span></p>
</div>
<ul>
<li><span class="sentence"><code>thisRef: E</code> is the reference to the enclosing entity</span>
<ul>
<li><span class="sentence">holds the enclosing class or object instance in case of classifier property</span></li>
<li><span class="sentence">is <code>null</code> for <a href="#local-property-declaration">local properties</a></span></li>
</ul></li>
<li><span class="sentence"><code>property: PropertyInfo</code> contains runtime-available information about the declared property, most importantly</span>
<ul>
<li><span class="sentence"><code>property.name</code> holds the property name</span></li>
</ul></li>
<li><span class="sentence"><code>value: R</code> is the new property value</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This convention implies the following requirements on the <code>setValue</code> function</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(S &lt;: E\)</span>, where <span class="math inline">\(S\)</span> is the type of the enclosing entity</span></li>
<li><span class="sentence"><span class="math inline">\(\text{KProperty&lt;*&gt;} &lt;: \text{PropertyInfo}\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(R\)</span> should be in a supertype relation with the delegated property type <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(U\)</span> is ignored</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">In case of the local property, enclosing entity has the type <code>Nothing?</code></span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The delegated property is expanded as follows.</span></p>
</div>
<div class="sourceCode" id="cb11"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="co"> * Actual code</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="co"> */</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="kw">class</span> C {</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    <span class="kw">var</span> <span class="va">prop</span>: Type <span class="kw">by</span> DelegateExpression</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="co">/*</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9"><span class="co"> * Expanded code</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10"><span class="co"> */</span></a>
<a class="sourceLine" id="cb11-11" data-line-number="11"><span class="kw">class</span> C {</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">    <span class="kw">private</span> <span class="kw">val</span> <span class="va">prop</span>$delegate = DelegateExpression</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">    <span class="kw">var</span> <span class="va">prop</span>: Type</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">        <span class="kw">get</span>() = prop$delegate.getValue(<span class="kw">this</span>, <span class="kw">this</span>::prop)</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">        <span class="kw">set</span>(value: Type) = prop$delegate.setValue(<span class="kw">this</span>, <span class="kw">this</span>::prop, value)</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">}</a></code></pre></div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(provideDelegate)</span></p>
</div>
</div>
<h4 id="local-property-declaration">Local property declaration</h4>
<div class="paragraph">
<p><span class="sentence">If a property declaration is local, it creates a local entity which follows most of the same rules as the ones for regular property declarations. </span><span class="sentence">However, local property declarations cannot have custom getters or setters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Local property declarations also support <em>destructive</em> declaration in the form of</span></p>
</div>
<div class="sourceCode" id="cb12"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">val</span> (<span class="va">a</span>: T, b: U, c: V, ...) = e</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">which is a syntactic sygar for the following expansion</span></p>
</div>
<div class="sourceCode" id="cb13"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">val</span> <span class="va">a</span>: T = e.component1()</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="kw">val</span> <span class="va">b</span>: U = e.component2()</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="kw">val</span> <span class="va">c</span>: V = e.component3()</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">...</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where <code>componentN()</code> should be a valid operator function available on the result of <code>e</code>. </span><span class="sentence">Each individual component property follows the rules for regular local property declaration.</span></p>
</div>
<h4 id="getters-and-setters">Getters and setters</h4>
<div class="paragraph">
<p><span class="sentence">As mentioned before, a property declaration may include a custom getter and/or custom setter (together called <em>accessors</em>) in the form of</span></p>
</div>
<div class="sourceCode" id="cb14"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">    <span class="kw">get</span>(): TG { ... }</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    <span class="kw">set</span>(anyValidArgumentName: TS): RT { ... }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">These functions have the following requirements</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(TG \equiv T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(TS \equiv T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(RT \equiv \mathtt{kotlin.Unit}\)</span></span></li>
<li><div class="paragraph">
<p><span class="sentence">Types <span class="math inline">\(TG\)</span>, <span class="math inline">\(TS\)</span> and <span class="math inline">\(RT\)</span> are optional and may be omitted from the declaration</span></p>
</div></li>
<li><span class="sentence">Read-only properties may have a custom getter, but not a custom setter</span></li>
<li><div class="paragraph">
<p><span class="sentence">Mutable properties may have any combination of a custom getter and a custom setter</span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">Setter argument may have any valid identifier as argument name</span></p>
</div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: Regular coding convention recommends <code>value</code> as the name for the setter argument</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">One can also ommit the accessor body, in which case a <em>default</em> implementation is used (also known as default accessor).</span></p>
</div>
<div class="sourceCode" id="cb15"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">    <span class="kw">get</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    <span class="kw">set</span></a></code></pre></div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This notation is usually used if you need to change some aspects of an accessor (i.e., its visibility) without changing the default implementation.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Getters and setters allow one to customize how the property is accessed, and may need access to the propertyâ€™s <em>backing field</em>, which is responsible for actually storing the property data. </span><span class="sentence">It is accessed via the special <code>field</code> property available inside accessor body, which follows these conventions</span></p>
</div>
<ul>
<li><span class="sentence">For a property declaration of type <code>T</code>, <code>field</code> has the same type <code>T</code></span></li>
<li><span class="sentence"><code>field</code> is read-only inside getter body</span></li>
<li><span class="sentence"><code>field</code> is mutable inside setter body</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">However, the backing field is created for a property only in the following cases</span></p>
</div>
<ul>
<li><span class="sentence">A property has no custom accessors</span></li>
<li><span class="sentence">A property has a default accessor</span></li>
<li><span class="sentence">A property has a custom accessor, and it uses <code>field</code> property</span></li>
<li><span class="sentence">A mutable property has a custom getter or setter, but not both</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">In all other cases a property has no backing field.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Read/write access to the property is replaced with getter/setter invocation respectively.</span></p>
</div>
<h4 id="extension-property-declaration">Extension property declaration</h4>
<div class="paragraph">
<p><span class="sentence">An <em>extension property declaration</em> is similar to a standard property declaration, but, very much alike an <a href="#extension-function-declaration">extension function</a>, introduces an additional parameter to the property called <em>the receiver parameter</em>. </span><span class="sentence">This is different from usual property declarations, that do not have any parameters. </span><span class="sentence">There are other differences from standar property declarations:</span></p>
</div>
<ul>
<li><span class="sentence">Extension properties cannot have initializers</span></li>
<li><span class="sentence">Extension properties cannot have backing fields</span></li>
<li><span class="sentence">Extension properties cannot have default accessors</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, on can say that extension properties have no state of their own. </span><span class="sentence">Only properties that use other objectsâ€™ storage facilities and/or uses constant data can be extension properties.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Aside from these differences, extension properties are similar to regular properties, but, when accessing such a property one always need to supply a <a href="#receivers"><em>receiver</em></a>, implicit or explicit. </span><span class="sentence">Also, unlike regular properties, the type of the receiver must be a subtype of the receiver parameter, and the value that is supplied as the receiver is bound to the receiver parameter. </span><span class="sentence">For more information on how a particular receiver for each access is chosen, please refer to the <a href="#overload-resolution">overloading section</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The receiver parameter can be accessed inside getter and setter scopes of the property as the implicit receiver or <code>this</code>. </span><span class="sentence">It may also be accessed inside nested scopes using [labeled <code>this</code> syntax][] using the name of the property declared as the label. </span><span class="sentence">For delegated properties, the value passed into the operator functions <code>getValue</code> and <code>setValue</code> as the receiver is the value of the receiver parameter, rather than the value of the outer classifier. </span><span class="sentence">This is also true for local extension properties: while regular local properties are passed <code>null</code> as the first argument of these operator functions, local extension properties are passed the value of the receiver argument instead.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: when declaring extension properties inside classifier declarations, this receiver takes precedence over the classifier object, which is usually the current receiver inside nested properties</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">For all other purposes, extension properties are not different from non-extension properties.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Examples:</span></p>
</div>
<div class="sourceCode" id="cb16"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">val</span> <span class="va">Int</span>.foo: <span class="kw">Int</span> <span class="kw">get</span>() = <span class="kw">this</span> + <span class="dv">1</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    println(<span class="fl">2.f</span>oo.foo) <span class="co">// prints &quot;4&quot;</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb16-6" data-line-number="6"></a>
<a class="sourceLine" id="cb16-7" data-line-number="7"><span class="kw">class</span> Bar {</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">    <span class="kw">val</span> <span class="va">foo</span> <span class="kw">get</span>() = <span class="kw">this</span> <span class="co">// returns type Bar</span></a>
<a class="sourceLine" id="cb16-9" data-line-number="9">    <span class="kw">val</span> <span class="va">Int</span>.foo <span class="kw">get</span>() = <span class="kw">this</span> <span class="co">// returns type Int</span></a>
<a class="sourceLine" id="cb16-10" data-line-number="10">}</a></code></pre></div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(More examples (delegation, at least))</span></p>
</div>
</div>
<h4 id="property-initialization">Property initialization</h4>
<div class="paragraph">
<p><span class="sentence">All non-abstract properties must be definitely initialized before their first use. </span><span class="sentence">To guarantee this, Kotlin compiler uses a number of analyses which are described in more detail <a href="#control--and-data-flow-analysis">here</a>.</span></p>
</div>
<h3 id="type-alias">Type alias</h3>
<div id="grammar-rule-typeAlias-pasted-9" class="grammar-rule">
<dl>
<dt><strong><em>typeAlias</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'typealias'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'='</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Type alias introduces an alternative name for the specified type and supports both simple and parameterized types. </span><span class="sentence">If type alias is parameterized, its type parameters must be <a href="#type-parameters">unbounded</a>. </span><span class="sentence">Another restriction is that recursive type aliases are forbidden â€” the type alias name cannot be used in its own right-hand side.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">At the moment, Kotlin supports only top-level type aliases. </span><span class="sentence">The scope where it is accessible is defined by its [<em>visibility modifiers</em>][Visibility].</span></p>
</div>
<h3 id="declarations-with-type-parameters">Declarations with type parameters</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h3 id="declaration-modifiers">Declaration modifiers</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(declaration scope)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<code>open</code>)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<code>abstract</code>)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<code>lateinit</code>)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<code>const</code>)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(overriding vs overloading vs shadowing)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(visibility)</span></p>
</div>
</div>
<h2 id="statements">Statements</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<div id="grammar-rule-statements-pasted-10" class="grammar-rule">
<dl>
<dt><strong><em>statements</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-statement">statement</a></em> {<em><a href="#grammar-rule-semis">semis</a></em> <em><a href="#grammar-rule-statement">statement</a></em>} [<em><a href="#grammar-rule-semis">semis</a></em>]]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-statement-pasted-11" class="grammar-rule">
<dl>
<dt><strong><em>statement</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-label">label</a></em> | <em><a href="#grammar-rule-annotation">annotation</a></em>} (<em><a href="#grammar-rule-declaration">declaration</a></em> | <em><a href="#grammar-rule-assignment">assignment</a></em> | <em><a href="#grammar-rule-loopStatement">loopStatement</a></em> | <em><a href="#grammar-rule-expression">expression</a></em>)</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Unlike some other languages, Kotlin does not explicitly distinguish between statements, expressions and declarations, i.e., expressions and declarations can be used in statement positions. </span><span class="sentence">This section focuses on those statements that are <em>not</em> expressions or declarations. </span><span class="sentence">For information on those parts of Kotlin, please refer to the <a href="#expressions">Expressions</a> and <a href="#declarations">Declarations</a> sections of the specification.</span></p>
</div>
<h3 id="assignments">Assignments</h3>
<div id="grammar-rule-assignment-pasted-12" class="grammar-rule">
<dl>
<dt><strong><em>assignment</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-directlyAssignableExpression">directlyAssignableExpression</a></em> <code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)<br />
| (<em><a href="#grammar-rule-assignableExpression">assignableExpression</a></em> <em><a href="#grammar-rule-assignmentAndOperator">assignmentAndOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-assignmentAndOperator-pasted-13" class="grammar-rule">
<dl>
<dt><strong><em>assignmentAndOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'+='</code><br />
| <code>'-='</code><br />
| <code>'*='</code><br />
| <code>'/='</code><br />
| <code>'%='</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>assignment</em> is a statement that writes a new value to some program entity, denoted by its left-hand side. </span><span class="sentence">Both left-hand and right-hand sides of an assignment must be expressions, more so, there are several restrictions for the expression on the left-hand side.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For an expression to be <em>assignable</em>, i.e.Â be allowed to occur on the left-hand side of an assignment, it <strong>must</strong> be one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">an identifier referring to a mutable property;</span></li>
<li><span class="sentence">a navigation expression referring to a mutable property;</span></li>
<li><span class="sentence">an indexing expression.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(switch to navigation paths when we have them?)</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: Kotlin assignments <strong>are not</strong> expressions and cannot be used as such.</span></p>
</div>
</blockquote>
<h4 id="simple-assignments">Simple assignments</h4>
<div class="paragraph">
<p><span class="sentence">A <em>simple assigment</em> is an assignment which uses the assign operator <code>=</code>. </span><span class="sentence">If the left-hand side of an assignment refers to a mutable property, a value of that property is changed when an assignment is evaluated, using the following rules (applied in order).</span></p>
</div>
<ul>
<li><span class="sentence">If a property is <a href="#delegated-property-declaration">delegated</a>, the corresponding operator function <code>setValue</code> is called using the right-hand side expression as the <code>value</code> argument;</span></li>
<li><span class="sentence">If a property has a <a href="#getters-and-setters">setter</a>, it is called using the right-hand side expression as its argument;</span></li>
<li><span class="sentence">Otherwise, if a property is a <a href="#mutable-property-declaration">mutable property</a>, its value is changed to the evaluation result of the right-hand side expression.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If the left-hand side of an assignment is an indexing expression, the whole statement is treated as an <a href="#overloadable-operators">overloaded operator</a> with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(A[B_1,B_2,B_3,\ldots,B_N] = C\)</span> is the same as calling <span class="math inline">\(A\text{.set}(B_1,B_2,B_3,\ldots,B_N,C)\)</span> where <code>set</code> is a suitable operator function.</span></p>
</div>
<h4 id="operator-assignments">Operator assignments</h4>
<div class="paragraph">
<p><span class="sentence">An <em>operator assignment</em> is a combined-form assignment which involves one of the following operators: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>. </span><span class="sentence">All of these operators are overloadable operator functions with the following expansions (applied in order):</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>+=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following:</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.plusAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>plusAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.plus(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>plus</code> operator function exists and is available.</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>-=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following:</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.minusAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>minusAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.minus(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>minus</code> operator function exists and is available.</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>*=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following:</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.timesAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>timesAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.times(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>times</code> operator function exists and is available.</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>/=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following:</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.divAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>divAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.div(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>div</code> operator function exists and is available;</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>%=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following:</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.remAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>remAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.rem(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>rem</code> operator function exists and is available.</span></li>
</ul></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as of Kotlin version 1.2.31, there are additional overloadable functions for <code>%</code> called <code>mod</code>/<code>modAssign</code>, which are deprecated.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">After the expansion, the resulting [function call expression][Function call expressions] or <a href="#simple-assignments">simple assignment</a> is processed according to their corresponding rules.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: although for most real-world use cases operators <code>++</code> and <code>--</code> are similar to operator assignments, in Kotlin they are expressions and are described in the <a href="#expressions">corresponding section</a> of this specification.</span></p>
</div>
</blockquote>
<h3 id="loop-statements">Loop statements</h3>
<div class="paragraph">
<p><span class="sentence">Loop statements describe an evaluation of a certain number of statements repeatedly until a <em>loop exit condition</em> applies.</span></p>
</div>
<div id="grammar-rule-loopStatement-pasted-14" class="grammar-rule">
<dl>
<dt><strong><em>loopStatement</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-forStatement">forStatement</a></em><br />
| <em><a href="#grammar-rule-whileStatement">whileStatement</a></em><br />
| <em><a href="#grammar-rule-doWhileStatement">doWhileStatement</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Loops are closely related to the semantics of <a href="#jump-expressions">jump expressions</a>, as these expressions, namely <a href="#break-expression"><code>break</code></a> and <a href="#continue-expression"><code>continue</code></a>, are only allowed in a body of a loop. </span><span class="sentence">Please refer to the corresponding sections for details.</span></p>
</div>
<h4 id="while-loop-statement">While-loop statement</h4>
<div id="grammar-rule-whileStatement-pasted-15" class="grammar-rule">
<dl>
<dt><strong><em>whileStatement</em>:</strong></dt>
<dd><span class="sentence">(<code>'while'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> <em><a href="#grammar-rule-expression">expression</a></em> <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>)<br />
| (<code>'while'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> <em><a href="#grammar-rule-expression">expression</a></em> <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>';'</code>)</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>while-loop statement</em> is similar to an <a href="#conditional-expression"><code>if</code> expression</a> in that it also has a condition expression and a body consisting of zero or more statements. </span><span class="sentence">While-loop statement evaluating its body repeatedly for as long as its condition expression evaluates to true or a <a href="#jump-expressions">jump expression</a> is evaluated to finish the loop.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this also means that the condition expression is evaluated before every evaluation of the body, including the first one.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The while-loop condition expression <strong>must be a subtype</strong> of <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="do-while-loop-statement">Do-while-loop statement</h4>
<div id="grammar-rule-doWhileStatement-pasted-16" class="grammar-rule">
<dl>
<dt><strong><em>doWhileStatement</em>:</strong></dt>
<dd><span class="sentence"><code>'do'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'while'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'('</code><br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>do-while-loop statement</em>, similarly to a while-loop statement, also describes a loop, with the following differences. </span><span class="sentence">First, it has a different syntax. </span><span class="sentence">Second, it evaluates the loop condition expression <strong>after</strong> evaluating the loop body.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this also means that the body is always evaluated at least once.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The do-while-loop condition expression <strong>must be a subtype</strong> of <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="for-loop-statement">For-loop statement</h4>
<div id="grammar-rule-forStatement-pasted-17" class="grammar-rule">
<dl>
<dt><strong><em>forStatement</em>:</strong></dt>
<dd><span class="sentence"><code>'for'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'('</code><br />
{<em><a href="#grammar-rule-annotation">annotation</a></em>}<br />
(<em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em> | <em><a href="#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em>)<br />
<code>'in'</code><br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
<code>')'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>]</span>
</dd>
</dl>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: unlike most other languages, Kotlin does not have a free-form condition-based for loops. </span><span class="sentence">The only form of a for-loop available in Kotlin is the â€œforeachâ€ loop, which iterates over lists, arrays and other data structures.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A <em>for-loop statement</em> is a special kind of loop statement used to iterate over some data structure viewed as an iterable collection of elements. </span><span class="sentence">A for-loop statement consists of a loop body, a <strong>container expression</strong> and an <strong>iteration variable declaration</strong>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The for-loop is actually an <a href="#overloadable-operators">overloadable</a> syntax form with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>for(VarDecl in C) Body</code> is the same as</span></p>
</div>
<div class="sourceCode" id="cb17"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">val</span> <span class="va">__iterator</span> = C.iterator()</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="cf">while</span> (__iterator.hasNext()) {</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    VarDecl = __iterator.next()</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    &lt;... all the statements from Body&gt;</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where <code>iterator</code>, <code>hasNext</code>, <code>next</code> are all suitable operator functions available in the current scope.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: the expansion is hygenic, i.e., the generated iterator variable never clashes with any other variable in the program and cannot be accessed outside the expansion.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(What about iterator value life-time and such?)</span></p>
</div>
</div>
<h3 id="code-blocks">Code blocks</h3>
<div id="grammar-rule-block-pasted-18" class="grammar-rule">
<dl>
<dt><strong><em>block</em>:</strong></dt>
<dd><span class="sentence"><code>'{'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-statements">statements</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-statements-pasted-19" class="grammar-rule">
<dl>
<dt><strong><em>statements</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-statement">statement</a></em> {<em><a href="#grammar-rule-semis">semis</a></em> <em><a href="#grammar-rule-statement">statement</a></em>} [<em><a href="#grammar-rule-semis">semis</a></em>]]</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>code block</em> is a sequence of zero or more statements between curly braces separated by newlines or/and semicolons. </span><span class="sentence">Evaluating a code block means evaluating all its statements in the order they are given inside of it.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: Unlike some other languages, Kotlin does <strong>not</strong> support code blocks as statements; a curly-braces code block in a statement position is, in fact, a <a href="#lambda-literals">lambda literal</a>.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A <em>last expression</em> of a code block is the last statement in it (if any) if and only if this statement is also an expression. </span><span class="sentence">The last expressions are important when defining functions and control structure expressions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A code block is said to contain no last expression if it does not contain any statements or its last statement is not an expression (e.g., it is an assignment, a loop or a declaration).</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: you may consider the case of a missing last expression as if a synthetic last expression with no runtime semantics and type <code>kotlin.Unit</code> is introduced in its place.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A <em>control structure body</em> is either a single statement or a code block. </span><span class="sentence">A <em>last expression</em> of a control structure body <code>CSB</code> is either the last expression of a code block (if <code>CSB</code> is a code block) or the single statement itself (if <code>CSB</code> is an expression). </span><span class="sentence">If a control structure body is not a code block or an expression, it has no last expression.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this is equivalent to wrapping the single statement in a new synthetic code block.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">In some contexts, a control structure body is expected to have a value and/or a type. </span><span class="sentence">The value of a control structure body is:</span></p>
</div>
<ul>
<li><span class="sentence">the value of its last expression if it exists;</span></li>
<li><span class="sentence">the singleton <code>kotlin.Unit</code> object otherwise.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The type of a control structure body is the type of its value.</span></p>
</div>
<h3 id="todo">TODO</h3>
<ul>
<li><span class="sentence">Are declarations statements or not?</span>
<ul>
<li><span class="sentence">In the current grammar, they are</span></li>
</ul></li>
<li><span class="sentence">How expansions with new variables actually work</span></li>
</ul>
<h2 id="expressions">Expressions</h2>
<h3 id="glossary-3">Glossary</h3>
<dl>
<dt>CSB</dt>
<dd><span class="sentence"><a href="#code-blocks">Control structure body</a></span>
</dd>
</dl>
<h3 id="introduction-3">Introduction</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">An expression may be <em>used as a statement</em> or <em>used as an expression</em> depending on the context. </span><span class="sentence">As all expressions are valid <a href="#statements">statements</a>, free expressions may be used as single statements or inside code blocks.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An expression is used as an expression, if it is encountered in any position where a statement is not allowed, for example, as an operand to an operator or as an immediate argument for a function call. </span><span class="sentence">An expression is used as a statement if it is encountered in any position where a statement is allowed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Some expressions are only allowed to be used as statements, if certain restrictions are met; this may affect the semantics, the compile-time type information or/and the safety of these expressions.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(strong/soft keywords?)</span></p>
</div>
</div>
<h3 id="constant-literals">Constant literals</h3>
<div class="paragraph">
<p><span class="sentence">Constant literals are expressions which describe constant values. </span><span class="sentence">Every constant literal is defined to have a single standard library type, whichever it is defined to be on current platform. </span><span class="sentence">All constant literals are evaluated immediately.</span></p>
</div>
<h4 id="boolean-literals">Boolean literals</h4>
<dl>
<dt><strong><em>BooleanLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>true</code> | <code>false</code></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Keywords <code>true</code> and <code>false</code> denote boolean literals of the same values. </span><span class="sentence">These are strong keywords which cannot be used as identifiers unless [escaped][Escaped identifiers]. </span><span class="sentence">Values <code>true</code> and <code>false</code> always have the type <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="integer-literals">Integer literals</h4>
<dl>
<dt><strong><em>IntegerLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigitNoZero</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
</dd>
<dt><strong><em>HexLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>0</code> (<code>x</code>|<code>X</code>) <em>HexDigit</em> {<em>HexDigitOrSeparator</em>} <em>HexDigit</em><br />
| <code>0</code> (<code>x</code>|<code>X</code>) <em>HexDigit</em></span>
</dd>
<dt><strong><em>BinLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>0</code> (<code>b</code>|<code>B</code>) <em>BinDigit</em> {<em>BinDigitOrSeparator</em>} <em>BinDigit</em><br />
| <code>0</code> (<code>b</code>|<code>B</code>) <em>BinDigit</em></span>
</dd>
<dt><strong><em>DecDigitNoZero</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> - <code>0</code></span>
</dd>
<dt><strong><em>DecDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> | <em>Underscore</em></span>
</dd>
<dt><strong><em>HexDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>HexDigit</em> | <em>Underscore</em></span>
</dd>
<dt><strong><em>BinDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>BinDigit</em> | <em>Underscore</em></span>
</dd>
<dt><strong><em>DecDigits</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
</dd>
</dl>
<h5 id="decimal-integer-literals">Decimal integer literals</h5>
<div class="paragraph">
<p><span class="sentence">A sequence of decimal digit symbols (<code>0</code> though <code>9</code>) is a decimal integer literal. </span><span class="sentence">Digits may be separated by an underscore symbol, but no underscore can be placed before the first digit or after the last one.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: unlike other languages, Kotlin does not support octal literals. </span><span class="sentence">Even more so, any decimal literal starting with digit <code>0</code> and containing more than 1 digit is not a valid decimal literal.</span></p>
</div>
</blockquote>
<h5 id="hexadecimal-integer-literals">Hexadecimal integer literals</h5>
<div class="paragraph">
<p><span class="sentence">A sequence of hexadecimal digit symbols (<code>0</code> through <code>9</code>, <code>a</code> through <code>f</code>, <code>A</code> through <code>F</code>) prefixed by <code>0x</code> or <code>0X</code> is a hexadecimal integer literal. </span><span class="sentence">Digits may be separated by an underscore symbol, but no underscore can be placed before the first digit or after the last one.</span></p>
</div>
<h5 id="binary-integer-literals">Binary integer literals</h5>
<div class="paragraph">
<p><span class="sentence">A sequence of binary digit symbols (<code>0</code> or <code>1</code>) prefixed by <code>0b</code> or <code>0B</code> is a binary integer literal. </span><span class="sentence">Digits may be separated by an underscore symbol, but no underscore can be placed before the first digit or after the last one.</span></p>
</div>
<h5 id="long-integer-literals">Long integer literals</h5>
<div class="paragraph">
<p><span class="sentence">Any of the decimal, hexadecimal or binary literals may be suffixed by the long literal mark (symbol <code>L</code>). </span><span class="sentence">An integer literal with the long literal mark has type <code>kotlin.Long</code>; an integer literal without it has one of the types <code>kotlin.Int</code>/<code>kotlin.Short</code>/<code>kotlin.Byte</code> (the selected type is dependent on the context), if its value is in range of the corresponding type, or type <code>kotlin.Long</code> otherwise.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(ranges for integer literals)</span></p>
</div>
</div>
<h4 id="real-literals">Real literals</h4>
<dl>
<dt><strong><em>RealLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>FloatLiteral</em> | <em>DoubleLiteral</em></span>
</dd>
<dt><strong><em>FloatLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>DoubleLiteral</em> (<code>f</code> | <code>F</code>) | <em>DecDigits</em> (<code>f</code> | <code>F</code>)</span>
</dd>
<dt><strong><em>DoubleLiteral</em>:</strong></dt>
<dd><span class="sentence">[<em>DecDigits</em>] <code>.</code> <em>DecDigits</em> [<em>DoubleExponent</em>] | <em>DecDigits</em> <em>DoubleExponent</em></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">A <em>real literal</em> consists of the following parts: the whole-number part, the decimal point (ASCII period character <code>.</code>), the fraction part and the exponent. </span><span class="sentence">Unlike other languages, Kotlin real literals may only be expressed in decimal numbers. </span><span class="sentence">A real literal may also be followed by a type suffix (<code>f</code> or <code>F</code>).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The exponent is an exponent mark (<code>e</code> or <code>E</code>) followed by an optionaly signed decimal integer (a sequence of decimal digits).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The whole-number part and the exponent part may be omitted. </span><span class="sentence">The fraction part may be omitted only together with the decimal point, if the whole-number part and either the exponent part or the type suffix are present. </span><span class="sentence">Unlike other languages, Kotlin does not support omitting the fraction part, but leaving the decimal point in.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The digits of the whole-number part or the fraction part or the exponent may be optionally separated by underscores, but an underscore may not be placed between, before, or after these parts. </span><span class="sentence">It also may not be placed before or after the exponent mark symbol.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A real literal without the type suffix has type <code>kotlin.Double</code>, a real literal with the type suffix has type <code>kotlin.Float</code>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means there is no special suffix associated with type <code>kotlin.Double</code>.</span></p>
</div>
</blockquote>
<h4 id="character-literals">Character literals</h4>
<dl>
<dt><strong><em>CharacterLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'</code> (<em>EscapeSeq</em> | <em>&lt;any character except CR, LF, <code>'</code> and <code>\</code>&gt;</em>) <code>'</code></span>
</dd>
<dt><strong><em>EscapeSeq</em>:</strong></dt>
<dd><span class="sentence"><em>UnicodeCharacterLiteral</em> | <em>EscapedCharacter</em></span>
</dd>
<dt><strong><em>UnicodeCharacterLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>\</code> <code>u</code> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em></span>
</dd>
<dt><strong><em>EscapedCharacter</em>:</strong></dt>
<dd><span class="sentence"><code>\</code> (<code>t</code> | <code>b</code> | <code>r</code> | <code>n</code> | <code>'</code> | <code>&quot;</code> | <code>\</code> | <code>$</code>)</span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">A <em>character literal</em> defines a constant holding a unicode character value. </span><span class="sentence">A simply-formed character literal is any symbol between two single quotation marks (ASCII single quotation character <code>'</code>), excluding newline symbols (<em>CR</em> and <em>LF</em>), the single quotation mark itself and the escaping mark (ASCII backslash character <code>\</code>).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A character literal may also contain an escaped symbol of two kinds: a simple escaped symbol or a unicode codepoint. </span><span class="sentence">Simple escaped symbols include:</span></p>
</div>
<ul>
<li><span class="sentence"><code>\t</code> â€” the unicode TAB symbol <span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\b</code> â€” the unicode BACKSPACE symbol <span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\r</code> â€” <em>CR</em>;</span></li>
<li><span class="sentence"><code>\n</code> â€” <em>LF</em>;</span></li>
<li><span class="sentence"><code>\'</code> â€” the unicode single quotation symbol <span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\&quot;</code> â€” the unicode double quotation symbol <span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\\</code> â€” the unicode backslash symbol symbol <span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\$</code> â€” the unicode DOLLAR symbol <span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">A unicode codepoint escaped symbol is the symbol <code>\u</code> followed by exactly four hexadecimal digits. </span><span class="sentence">It represents the unicode symbol with the codepoint equal to the number represented by these four digits.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means unicode codepoint escaped symbols support only unicode symbols in range from U+0000 to U+FFFF.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">All character literals have type <code>kotlin.Char</code>.</span></p>
</div>
<h4 id="string-literals-1">String literals</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin supports [string interpolation][String interpolation expression] which supersedes traditional string literals. </span><span class="sentence">For further details, please refer to the corresponding section.</span></p>
</div>
<h4 id="null-literal">Null literal</h4>
<div class="paragraph">
<p><span class="sentence">The keyword <code>null</code> denotes the <strong>null reference</strong>, which represents an absence of a value and is a valid value only for <a href="#nullable-types">nullable types</a>. </span><span class="sentence">Null reference has type <a href="#kotlin.nothing"><code>kotlin.Nothing?</code></a> and is, by definition, the only value of this type.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(rearrange these sections)</span></p>
</div>
</div>
<h3 id="try-expression">Try-expression</h3>
<div id="grammar-rule-tryExpression-pasted-20" class="grammar-rule">
<dl>
<dt><strong><em>tryExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'try'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-block">block</a></em> ((({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-catchBlock">catchBlock</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-catchBlock">catchBlock</a></em>}) [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-finallyBlock">finallyBlock</a></em>]) | ({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-finallyBlock">finallyBlock</a></em>))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-catchBlock-pasted-21" class="grammar-rule">
<dl>
<dt><strong><em>catchBlock</em>:</strong></dt>
<dd><span class="sentence"><code>'catch'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'('</code><br />
{<em><a href="#grammar-rule-annotation">annotation</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
<code>':'</code><br />
<em><a href="#grammar-rule-userType">userType</a></em><br />
<code>')'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-finallyBlock-pasted-22" class="grammar-rule">
<dl>
<dt><strong><em>finallyBlock</em>:</strong></dt>
<dd><span class="sentence"><code>'finally'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>try-expression</em> is an expression starting with the keyword <code>try</code>. </span><span class="sentence">It consists of a <a href="#code-blocks">code block</a> (<em>try body</em>) and one or more of the following kinds of blocks: zero or more <em>catch blocks</em> and an optional <em>finally block</em>. </span><span class="sentence">A <em>catch block</em> starts with the soft keyword <code>catch</code> with a single <em>exception parameter</em>, which is followed by a <a href="#code-blocks">code block</a>. </span><span class="sentence">A <em>finally block</em> starts with the soft keyword <code>finally</code>, which is followed by a <a href="#code-blocks">code block</a>. </span><span class="sentence">A valid try-expression must have at least one catch or finally block.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The try-expression evaluation evaluates its body; if any statement in the try body throws an exception (of type <span class="math inline">\(E\)</span>), this exception, rather than being immediately propagated up the call stack, is checked for a matching catch block. </span><span class="sentence">If a catch block of this try-expression has an exception parameter of type <span class="math inline">\(T :&gt; E\)</span>, this catch block is evaluated immediately after the exception is thrown and the exception itself is passed inside the catch block as the corresponding parameter. </span><span class="sentence">If there are several catch blocks which match the exception type, the first one is picked.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Exception handling?)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">If there is a finally block, it is evaluated after the evaluation of all previous try-expression blocks, meaning:</span></p>
</div>
<ul>
<li><span class="sentence">If no exception is thrown during the evaluation of the try body, no catch blocks are executed, the finally block is evaluated after the try body, and the program execution continues as normal.</span></li>
<li><span class="sentence">If an exception was thrown, and one of the catch blocks matched its type, the finally block is evaluated after the evaluation of the matching catch block.</span></li>
<li><span class="sentence">If an exception was thrown, but no catch block matched its type, the finally block is evaluated before <a href="#exceptions">propagating the exception</a> up the call stack.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The value of the try-expression is the same as the value of the <a href="#code-blocks">last expression</a> of the try body (if no exception was thrown) or the value of the last expression of the matching catch block (if an exception was thrown and matched). </span><span class="sentence">All other situations mean that an exception is going to be propagated up the call stack, and the value of the try-expression becomes irrelevant.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as desribed, the finally block (if present) is executed regardless, but it has no effect on the value returned by the try-expression.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The type of the try-expression is the <a href="#least-upper-bound">least upper bound</a> of the types of the last expressions of the try body and the last expressions of all the catch blocks <span><span class="TODO">(TODO(not that simple))</span><span class="TODO-marker">*</span></span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: these rules mean the try-expression always may be used as an expression, as it always has a corresponding result value.</span></p>
</div>
</blockquote>
<h3 id="conditional-expression">Conditional expression</h3>
<div id="grammar-rule-ifExpression-pasted-23" class="grammar-rule">
<dl>
<dt><strong><em>ifExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'if'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> [[<code>';'</code>] {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'else'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>])<br />
| (<code>'if'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} [<code>';'</code> {<em><a href="#grammar-rule-NL">NL</a></em>}] <code>'else'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>)</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Conditional expressions</em> use a boolean value of one expression (<em>condition</em>) to decide which of the two <a href="#code-blocks">control structure bodies</a> (<em>branches</em>) should be evaluated. </span><span class="sentence">If the condition evaluates to <code>true</code>, the first branch (the <em>true branch</em>) is evaluated if it is present, otherwise the second branch (the <em>false branch</em>) is evaluated if it is present.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means the following branchless conditional expression, despite being of almost no practical use, is valid in Kotlin</span></p>
</div>
<div class="sourceCode" id="cb18"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="cf">if</span> (condition) <span class="cf">else</span>;</a></code></pre></div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The value of the resulting expression is the same as the value of the chosen branch.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of the resulting expression is the <a href="#least-upper-bound">least upper bound</a> of the types of two branches <span><span class="TODO">(TODO(not that simple))</span><span class="TODO-marker">*</span></span>, if both branches are present. </span><span class="sentence">If either of the branches are omitted, the resulting conditional expression has type <a href="#kotlin.unit"><code>kotlin.Unit</code></a> and may used only as a statement.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Examples?)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">The type of the condition expression must be a subtype of <code>kotlin.Boolean</code>, otherwise it is an error.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: when used as expressions, conditional expressions are special w.r.t. of operator precedence: they have the highest priority (the same as for all primary expressions) when placed on the right side of any binary expression, but when placed on the left side, they have the lowest priority. </span><span class="sentence">For details, see Kotlin <a href="#syntax-grammar">grammar</a>.</span></p>
</div>
</blockquote>
<h3 id="when-expression">When expression</h3>
<div id="grammar-rule-whenExpression-pasted-24" class="grammar-rule">
<dl>
<dt><strong><em>whenExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'when'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<code>'('</code> <em><a href="#grammar-rule-expression">expression</a></em> <code>')'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'{'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
{<em><a href="#grammar-rule-whenEntry">whenEntry</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>}}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenEntry-pasted-25" class="grammar-rule">
<dl>
<dt><strong><em>whenEntry</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-whenCondition">whenCondition</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-whenCondition">whenCondition</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>])<br />
| (<code>'else'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>])</span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenCondition-pasted-26" class="grammar-rule">
<dl>
<dt><strong><em>whenCondition</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-expression">expression</a></em><br />
| <em><a href="#grammar-rule-rangeTest">rangeTest</a></em><br />
| <em><a href="#grammar-rule-typeTest">typeTest</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-rangeTest-pasted-27" class="grammar-rule">
<dl>
<dt><strong><em>rangeTest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-inOperator">inOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeTest-pasted-28" class="grammar-rule">
<dl>
<dt><strong><em>typeTest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-isOperator">isOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>When expression</em> is similar to a <a href="#conditional-expression">conditional expression</a> in that it allows one of several different <a href="#code-blocks">control structure bodies</a> (<em>cases</em>) to be evaluated, depending on some boolean conditions. </span><span class="sentence">The key difference is exactly that a when expressions may include several different conditions with their corresponding control structure bodies. </span><span class="sentence">When expression has two different forms: with bound value and without it.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><strong>When expression without bound value</strong> (the form where the expression enclosed in parantheses after the <code>when</code> keyword is absent) evaluates one of the different CSBs based on its condition from the <em>when entry</em>. </span><span class="sentence">Each when entry consists of a boolean <em>condition</em> (or a special <code>else</code> condition) and its corresponding CSB. </span><span class="sentence">When entries are checked and evaluated in their order of appearance. </span><span class="sentence">If the condition evaluates to <code>true</code>, the corresponding CSB is evaluated and the value of when expression is the same as the value of the CSB. </span><span class="sentence">All remaining conditions and expressions are not evaluated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The <code>else</code> condition is a special condition which evaluates to <code>true</code> if none of the branches above it evaluated to <code>true</code>. </span><span class="sentence">The <code>else</code> condition <strong>must</strong> also be in the last when entry of when expression, otherwise it is a compile-time error.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, you can always replace the <code>else</code> condition with an always-<code>true</code> condition (e.g., boolean literal <code>true</code>) with no change to the resulting semantics.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence"><strong>When expression with bound value</strong> (the form where the expression enclosed in parantheses after the <code>when</code> keyword is present) are similar to the form without bound value, but use a different syntax for conditions. </span><span class="sentence">In fact, it supports three different condition forms:</span></p>
</div>
<ul>
<li><span class="sentence"><em>Type test condition</em>: <a href="#type-checking-expression">type checking operator</a> followed by a type (<code>is T</code>). </span><span class="sentence">The resulting condition is a <a href="#type-checking-expression">type check expression</a> of the form <code>boundValue is T</code>.</span></li>
<li><span class="sentence"><em>Contains test condition</em>: <a href="#containment-checking-expression">containment operator</a> followed by an expression (<code>in Expr</code>). </span><span class="sentence">The resulting condition is a <a href="#containment-checking-expression">containment check expression</a> of the form <code>boundValue in Expr</code>.</span></li>
<li><span class="sentence"><em>Any other expression</em> (<code>Expr</code>). </span><span class="sentence">The resulting condition is an <a href="#equality-expressions">equality check</a> of the form <code>boundValue == Expr</code>.</span></li>
<li><span class="sentence">The <code>else</code> condition, which is a special condition which evaluates to <code>true</code> if none of the branches above it evaluated to <code>true</code>. </span><span class="sentence">The <code>else</code> condition <strong>must</strong> also be in the last when entry of when expression, otherwise it is a compile-time error.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: the rule for â€œany other expressionâ€ means that if a when expression with bound value contains a boolean condition, this condition is <strong>checked for equality</strong> with the bound value, instead of being used directly for when entry selection.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Examples)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">The type of the resulting expression is the <a href="#least-upper-bound">least upper bound</a> of the types of all its entries <span><span class="TODO">(TODO(not that simple))</span><span class="TODO-marker">*</span></span>. </span><span class="sentence">If the when expression is not <a href="#exhaustive-when-expressions">exhaustive</a>, it has type <a href="#kotlin.unit"><code>kotlin.Unit</code></a> and may used only as a statement.</span></p>
</div>
<h4 id="exhaustive-when-expressions">Exhaustive when expressions</h4>
<div class="paragraph">
<p><span class="sentence">A when expression is called <strong><em>exhaustive</em></strong> if at least one of the following is true:</span></p>
</div>
<ul>
<li><span class="sentence">It has an <code>else</code> entry;</span></li>
<li><span class="sentence">It has a bound value and at least one of the following is true:</span>
<ul>
<li><span class="sentence">The bound expression is of type <code>kotlin.Boolean</code> and the conditions contain both:</span>
<ul>
<li><span class="sentence">A [constant expression][Constant expressions] evaluating to <code>true</code>;</span></li>
<li><span class="sentence">A [constant expression][Constant expressions] evaluating to <code>false</code>;</span></li>
</ul></li>
<li><span class="sentence">The bound expression is of a [<code>sealed class</code>][Sealed classes] type and all of its subtypes are covered using type test conditions in this expression. </span><span class="sentence">This should include checks for all direct subtypes of this sealed class. </span><span class="sentence">If any of the direct subtypes is also a sealed class, there should either be a check for this subtype or all its subtypes should be covered;</span></li>
<li><span class="sentence">The bound expression is of an [<code>enum class</code>][Enum classes] type and all its enumerated values are checked for equality using constant expression;</span></li>
<li><span class="sentence">The bound expression is of a <a href="#nullable-types">nullable type</a> <span class="math inline">\(T?\)</span> and one of the cases above is met for its non-nullable counterpart <span class="math inline">\(T\)</span> together with another condition which checks the bound value for equality with <code>null</code>.</span></li>
</ul></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Equality check with object behaves kinda like a type check. </span><span class="sentence">Or not.)</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, an exhaustive when expression is guaranteed to evaluate one of its CSBs regardless of the specific when conditions.</span></p>
</div>
</blockquote>
<h3 id="logical-disjunction-expression">Logical disjunction expression</h3>
<div id="grammar-rule-disjunction-pasted-29" class="grammar-rule">
<dl>
<dt><strong><em>disjunction</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-conjunction">conjunction</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'||'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-conjunction">conjunction</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Operator symbol <code>||</code> performs logical disjunction over two values of type <code>kotlin.Boolean</code>. </span><span class="sentence">This operator is <strong>lazy</strong>, meaning that it does not evaluate the right hand side argument unless the left hand side argument evaluated to <code>false</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Both operands of a logical disjunction expression must have a type which is a subtype of <code>kotlin.Boolean</code>, otherwise it is a type error. </span><span class="sentence">The type of logical disjunction expression is <code>kotlin.Boolean</code>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Types of errors? </span><span class="sentence">Compile-time, type, run-time, whatever?)</span></p>
</div>
</div>
<h3 id="logical-conjunction-expression">Logical conjunction expression</h3>
<div id="grammar-rule-conjunction-pasted-30" class="grammar-rule">
<dl>
<dt><strong><em>conjunction</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-equality">equality</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'&amp;&amp;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-equality">equality</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Operator symbol <code>&amp;&amp;</code> performs logical conjunction over two values of type <code>kotlin.Boolean</code>. </span><span class="sentence">This operator is <strong>lazy</strong>, meaning that it does not evaluate the right hand side argument unless the left hand side argument evaluated to <code>true</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Both operands of a logical conjunction expression must have a type which is a subtype of <code>kotlin.Boolean</code>, otherwise it is a type error. </span><span class="sentence">The type of logical disjunction expression is <code>kotlin.Boolean</code>.</span></p>
</div>
<h3 id="equality-expressions">Equality expressions</h3>
<div id="grammar-rule-equality-pasted-31" class="grammar-rule">
<dl>
<dt><strong><em>equality</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-comparison">comparison</a></em> {<em><a href="#grammar-rule-equalityOperator">equalityOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-comparison">comparison</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-equalityOperator-pasted-32" class="grammar-rule">
<dl>
<dt><strong><em>equalityOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'!='</code><br />
| <code>'!=='</code><br />
| <code>'=='</code><br />
| <code>'==='</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Equality expressions are binary expressions involving equality operators. </span><span class="sentence">There are two kinds of equality operators: <em>reference equality operators</em> and <em>value equality operators</em>.</span></p>
</div>
<h4 id="reference-equality-expressions">Reference equality expressions</h4>
<div class="paragraph">
<p><span class="sentence"><em>Reference equality expressions</em> are binary expressions which use reference equality operators: <code>===</code> and <code>!==</code>. </span><span class="sentence">These expressions check if two values are equal (<code>===</code>) or non-equal (<code>!==</code>) <em>by reference</em> â€” two values are equal by reference if and only if they represent the same runtime value.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For special values created without explicit constructor calls, notably, the constant literals and constant expressions composed of those literals, the following holds:</span></p>
</div>
<ul>
<li><span class="sentence">If these values are <a href="#value-equality-expressions">non-equal by value</a>, they are also non-equal by reference;</span></li>
<li><span class="sentence">Any instance of the null reference <code>null</code> is equal by reference to any other instance of the null reference;</span></li>
<li><span class="sentence">Otherwise, equality by reference is implementation-defined and must not be used as a means of comparing such values.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Reference equality expressions always have type <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="value-equality-expressions">Value equality expressions</h4>
<div class="paragraph">
<p><span class="sentence"><em>Value equality expressions</em> are binary expressions which use value equality operators: <code>==</code> and <code>!=</code>. </span><span class="sentence">These operators are <a href="#overloadable-operators">overloadable</a> with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>A == B</code> is exactly the same as <code>A?.equals(B) ?: (B === null)</code> where <code>equals</code> is a valid operator function available in the current scope;</span></li>
<li><span class="sentence"><code>A != B</code> is exactly the same as <code>!(A?.equals(B) ?: (B === null))</code> where <code>equals</code> is a valid operator function available in the current scope.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: <code>kotlin.Any</code> type has a built-in open operator member function <code>equals</code>, meaning there is always at least one available overloading candidate for any value equality expression.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Value equality expressions always have type <code>kotlin.Boolean</code>. </span><span class="sentence">If the corresponding operator function <code>equals</code> has a different return type, it is a compile-time error.</span></p>
</div>
<h3 id="comparison-expressions">Comparison expressions</h3>
<div id="grammar-rule-comparison-pasted-33" class="grammar-rule">
<dl>
<dt><strong><em>comparison</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-infixOperation">infixOperation</a></em> [<em><a href="#grammar-rule-comparisonOperator">comparisonOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-infixOperation">infixOperation</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-comparisonOperator-pasted-34" class="grammar-rule">
<dl>
<dt><strong><em>comparisonOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
| <code>'&gt;'</code><br />
| <code>'&lt;='</code><br />
| <code>'&gt;='</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Comparison expressions</em> are binary expressions which use the comparison operators: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code>. </span><span class="sentence">These operators are <a href="#overloadable-operators">overloadable</a> with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>A &lt; B</code> is exactly the same as <code>A.compareTo(B) [&lt;] 0</code></span></li>
<li><span class="sentence"><code>A &gt; B</code> is exactly the same as <code>0 [&lt;] A.compareTo(B)</code></span></li>
<li><span class="sentence"><code>A &lt;= B</code> is exactly the same as <code>!(A.compareTo(B) [&lt;] 0)</code></span></li>
<li><span class="sentence"><code>A &gt;= B</code> is exactly the same as <code>!(0 [&lt;] A.compareTo(B))</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>compareTo</code> is a valid operator function available in the current scope and <code>[&lt;]</code> (read â€œboxed lessâ€) is a special operator unavailable in user-side Kotlin which performs integer â€œless-thanâ€ comparison of two integer numbers.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The <code>compareTo</code> operator function must have a return type <code>kotlin.Int</code>, otherwise it is a compile-time error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">All comparison expressions always have type <code>kotlin.Boolean</code>.</span></p>
</div>
<h3 id="type-checking-and-containment-checking-expressions">Type-checking and containment-checking expressions</h3>
<div id="grammar-rule-infixOperation-pasted-35" class="grammar-rule">
<dl>
<dt><strong><em>infixOperation</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-elvisExpression">elvisExpression</a></em> {(<em><a href="#grammar-rule-inOperator">inOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-elvisExpression">elvisExpression</a></em>) | (<em><a href="#grammar-rule-isOperator">isOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>)}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-inOperator-pasted-36" class="grammar-rule">
<dl>
<dt><strong><em>inOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'in'</code><br />
| <em><a href="#grammar-rule-NOT_IN">NOT_IN</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-isOperator-pasted-37" class="grammar-rule">
<dl>
<dt><strong><em>isOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'is'</code><br />
| <em><a href="#grammar-rule-NOT_IS">NOT_IS</a></em></span>
</dd>
</dl>
</div>
<h4 id="type-checking-expression">Type-checking expression</h4>
<div class="paragraph">
<p><span class="sentence">A type-checking expression uses a type-checking operator <code>is</code> or <code>!is</code> and has an expression <span class="math inline">\(E\)</span> as a left-hand side operand and a type name <span class="math inline">\(T\)</span> as a right-hand side operand. </span><span class="sentence">The type <span class="math inline">\(T\)</span> must be <a href="#runtime-available-types">runtime-available</a>, otherwise it is a compiler error. </span><span class="sentence">A type-checking expression checks whether the runtime type of <span class="math inline">\(E\)</span> is a subtype of <span class="math inline">\(T\)</span> for <code>is</code> operator, or not a subtype of <span class="math inline">\(T\)</span> for <code>!is</code> operator.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Type-checking expression always has type <code>kotlin.Boolean</code>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: the expression <code>null is T?</code> for any type <code>T</code> always evaluates to <code>true</code>, as the type of the left-hand side (<code>null</code>) is <code>kotlin.Nothing?</code>, which is a subtype of any nullable type <code>T?</code>.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: type-checking expressions may create <a href="#smart-casts">smart casts</a>, for further details, refer to the corresponding section.</span></p>
</div>
</blockquote>
<h4 id="containment-checking-expression">Containment-checking expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>containment-checking expression</em> is a binary expression which uses a containment operator <code>in</code> or <code>!in</code>. </span><span class="sentence">These operators are <a href="#overloadable-operators">overloadable</a> with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>A in B</code> is exactly the same as <code>A.contains(B)</code>;</span></li>
<li><span class="sentence"><code>A !in B</code> is exactly the same as <code>!(A.contains(B))</code>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>contains</code> is a valid operator function available in the current scope.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The <code>contains</code> function must have a return type <code>kotlin.Boolean</code>, otherwise it is a compile-time error. </span><span class="sentence">Containment-checking expressions always have type <code>kotlin.Boolean</code>.</span></p>
</div>
<h3 id="elvis-operator-expression">Elvis operator expression</h3>
<div id="grammar-rule-elvisExpression-pasted-38" class="grammar-rule">
<dl>
<dt><strong><em>elvisExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-infixFunctionCall">infixFunctionCall</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-elvis">elvis</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-infixFunctionCall">infixFunctionCall</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>elvis operator expression</em> is a binary expression which uses an elvis operator (<code>?:</code>). </span><span class="sentence">It checks whether the left-hand side expression is reference equal to <code>null</code>, and, if it is, evaluates and return the right-hand side expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">This operator is <strong>lazy</strong>, meaning that if the left-hand side expression is not reference equal to <code>null</code>, the right-hand side expression is not evaluated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of elvis operator expression is the <a href="#least-upper-bound">least upper bound</a> of the non-nullable variant of the type of the left-hand side expression and the type of the right-hand side expression.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(not that simple either)</span></p>
</div>
</div>
<h3 id="range-expression">Range expression</h3>
<div id="grammar-rule-rangeExpression-pasted-39" class="grammar-rule">
<dl>
<dt><strong><em>rangeExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-additiveExpression">additiveExpression</a></em> {<code>'..'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-additiveExpression">additiveExpression</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>range expression</em> is a binary expression which uses a range operator <code>..</code>. </span><span class="sentence">It is an <a href="#overloadable-operators">overloadable</a> operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>A..B</code> is exactly the same as <code>A.rangeTo(B)</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>rangeTo</code> is a valid operator function available in the current scope.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The return type of this function is not restricted. </span><span class="sentence">A range expression has the same type as the return type of the corresponding <code>rangeTo</code> overload variant.</span></p>
</div>
<h3 id="additive-expression">Additive expression</h3>
<div id="grammar-rule-additiveExpression-pasted-40" class="grammar-rule">
<dl>
<dt><strong><em>additiveExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-multiplicativeExpression">multiplicativeExpression</a></em> {<em><a href="#grammar-rule-additiveOperator">additiveOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-multiplicativeExpression">multiplicativeExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-additiveOperator-pasted-41" class="grammar-rule">
<dl>
<dt><strong><em>additiveOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'+'</code><br />
| <code>'-'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>additive expression</em> is a binary expression which uses the addition (<code>+</code>) or subtraction (<code>-</code>) operators. </span><span class="sentence">These are <a href="#overloadable-operators">overloadable</a> operators with the following expansions:</span></p>
</div>
<ul>
<li><span class="sentence"><code>A + B</code> is exactly the same as <code>A.plus(B)</code></span></li>
<li><span class="sentence"><code>A - B</code> is exactly the same as <code>A.minus(B)</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>plus</code> or <code>minus</code> is a valid operator function available in the current scope.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The return type of these functions is not restricted. </span><span class="sentence">An additive expression has the same type as the return type of the corresponding operator function overload variant.</span></p>
</div>
<h3 id="multiplicative-expression">Multiplicative expression</h3>
<div id="grammar-rule-multiplicativeExpression-pasted-42" class="grammar-rule">
<dl>
<dt><strong><em>multiplicativeExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-asExpression">asExpression</a></em> {<em><a href="#grammar-rule-multiplicativeOperator">multiplicativeOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-asExpression">asExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiplicativeOperator-pasted-43" class="grammar-rule">
<dl>
<dt><strong><em>multiplicativeOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'*'</code><br />
| <code>'/'</code><br />
| <code>'%'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>multiplicative expression</em> is a binary expression which uses the multiplication (<code>*</code>), division (<code>/</code>) or remainder (<code>%</code>) operators. </span><span class="sentence">These are <a href="#overloadable-operators">overloadable</a> operators with the following expansions:</span></p>
</div>
<ul>
<li><span class="sentence"><code>A * B</code> is exactly the same as <code>A.times(B)</code></span></li>
<li><span class="sentence"><code>A / B</code> is exactly the same as <code>A.div(B)</code></span></li>
<li><span class="sentence"><code>A % B</code> is exactly the same as <code>A.rem(B)</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>times</code>, <code>div</code>, <code>rem</code> is a valid operator function available in the current scope.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as of Kotlin version 1.2.31, there exists an additional overloadable operator for <code>%</code> called <code>mod</code>, which is deprecated.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The return type of these functions is not restricted. </span><span class="sentence">A multiplicative expression has the same type as the return type of the corresponding operator function overload variant.</span></p>
</div>
<h3 id="cast-expression">Cast expression</h3>
<div id="grammar-rule-asExpression-pasted-44" class="grammar-rule">
<dl>
<dt><strong><em>asExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-prefixUnaryExpression">prefixUnaryExpression</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-asOperator">asOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-asOperator-pasted-45" class="grammar-rule">
<dl>
<dt><strong><em>asOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'as'</code><br />
| <code>'as?'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>cast expression</em> is a binary expression which uses the cast operators <code>as</code> or <code>as?</code> and has the form <code>E as/as? T</code>, where <span class="math inline">\(E\)</span> is an expression and <span class="math inline">\(T\)</span> is a type name.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An <strong><code>as</code> cast expression</strong> <code>E as T</code> is called <em>a unsafe cast</em> expression. </span><span class="sentence">This expression perform a runtime check whether the runtime type of <span class="math inline">\(E\)</span> is a <a href="#subtyping">subtype</a> of <span class="math inline">\(T\)</span> and throws an exception otherwise. </span><span class="sentence">If type <span class="math inline">\(T\)</span> is a <a href="#runtime-available-types">runtime-available</a> type without generic parameters, then this exception is thrown immediately when evaluating the cast expression, otherwise it is platform-dependent whether an exception is thrown at this point.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(We need to sort out undefined/implementation-defined/platform-defined)</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: even if the exception is not thrown when evaluating the cast expression, it is guaranteed to be thrown later when its result is used with any runtime-available type.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">An unsafe cast expression result always has the same type as the type <span class="math inline">\(T\)</span> specified in the expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An <strong><code>as?</code> cast expression</strong> <code>E as? T</code> is called <em>a checked cast</em> expression. </span><span class="sentence">This expression is similar to the unsafe cast expression in that it also does a runtime type check, but does not throw an exception if the types do not match, it returns <code>null</code> instead. </span><span class="sentence">If type <span class="math inline">\(T\)</span> is not a <a href="#runtime-available-types">runtime-available</a> type, then the check is not performed and <code>null</code> is never returned, leading to potential runtime errors later in the program execution. </span><span class="sentence">This situation should be reported as a compile-time warning.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: if type <span class="math inline">\(T\)</span> is a <a href="#runtime-available-types">runtime-available</a> type <strong>with</strong> generic parameters, type parameters are <strong>not</strong> checked w.r.t. subtyping. </span><span class="sentence">This is another porentially erroneous situation, which should be reported as a compile-time warning.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The checked cast expression type is the <a href="#nullable-types">nullable</a> variant of the type <span class="math inline">\(T\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: cast expressions may create <a href="#smart-casts">smart casts</a>, for further details, refer to the corresponding section.</span></p>
</div>
</blockquote>
<h3 id="prefix-expressions">Prefix expressions</h3>
<div id="grammar-rule-prefixUnaryExpression-pasted-46" class="grammar-rule">
<dl>
<dt><strong><em>prefixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-unaryPrefix">unaryPrefix</a></em>} <em><a href="#grammar-rule-postfixUnaryExpression">postfixUnaryExpression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-unaryPrefix-pasted-47" class="grammar-rule">
<dl>
<dt><strong><em>unaryPrefix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-annotation">annotation</a></em><br />
| <em><a href="#grammar-rule-label">label</a></em><br />
| (<em><a href="#grammar-rule-prefixUnaryOperator">prefixUnaryOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>})</span>
</dd>
</dl>
</div>
<div id="grammar-rule-prefixUnaryOperator-pasted-48" class="grammar-rule">
<dl>
<dt><strong><em>prefixUnaryOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'++'</code><br />
| <code>'--'</code><br />
| <code>'-'</code><br />
| <code>'+'</code><br />
| <em><a href="#grammar-rule-excl">excl</a></em></span>
</dd>
</dl>
</div>
<h4 id="annotated-and-labeled-expression">Annotated and labeled expression</h4>
<div class="paragraph">
<p><span class="sentence">Any expression in Kotlin may be prefixed with any number of <a href="#annotations">annotations</a> and [labels][Labels]. </span><span class="sentence">These do not change the value of the expression and can be used by external tools and for implementing platform-dependent features.</span></p>
</div>
<h4 id="prefix-increment-expression">Prefix increment expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>prefix increment</em> expression is an expression which uses the prefix form of operator <code>++</code>. </span><span class="sentence">It is an <a href="#overloadable-operators">overloadable</a> operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>++A</code> is exactly the same as <code>A = A.inc(); A</code> where <code>inc</code> is a valid operator function available in the current scope.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, <code>++A</code> assigns the result of <code>A.inc()</code> to <code>A</code> and then returns <code>A</code> as the result.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">For a prefix increment expression <code>++A</code> expression <code>A</code> must be <a href="#assignments">assignable expressions</a>. </span><span class="sentence">Otherwise, it is a compile-time error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A prefix increment expression has the same type as the return type of the corresponding <code>inc</code> overload variant.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as the result of <code>inc</code> is assigned to <code>A</code>, the return type of <code>inc</code> must be a subtype of <code>A</code>.</span></p>
</div>
</blockquote>
<h4 id="prefix-decrement-expression">Prefix decrement expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>prefix decrement</em> expression is an expression which uses the prefix form of operator <code>--</code>. </span><span class="sentence">It is an <a href="#overloadable-operators">overloadable</a> operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>--A</code> is exactly the same as <code>A = A.dec(); A</code> where <code>dec</code> is a valid operator function available in the current scope.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, <code>--A</code> assigns the result of <code>A.dec()</code> to <code>A</code> and then returns <code>A</code> as the result.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">For a prefix decrement expression <code>--A</code> expression <code>A</code> must be <a href="#assignments">assignable expressions</a>. </span><span class="sentence">Otherwise, it is a compile-time error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A prefix decrement expression has the same type as the return type of the corresponding <code>dec</code> overload variant.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as the result of <code>dec</code> is assigned to <code>A</code>, the return type of <code>dec</code> must be a subtype of <code>A</code>.</span></p>
</div>
</blockquote>
<h4 id="unary-minus-expression">Unary minus expression</h4>
<div class="paragraph">
<p><span class="sentence">An <em>unary minus</em> expression is an expression which uses the prefix form of operator <code>-</code>. </span><span class="sentence">It is an <a href="#overloadable-operators">overloadable</a> operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>-A</code> is exactly the same as <code>A.unaryMinus()</code> where <code>unaryMinus</code> is a valid operator function available in the current scope.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">No additional restrictions apply.</span></p>
</div>
<h4 id="unary-plus-expression">Unary plus expression</h4>
<div class="paragraph">
<p><span class="sentence">An <em>unary plus</em> expression is an expression which uses the prefix form of operator <code>+</code>. </span><span class="sentence">It is an <a href="#overloadable-operators">overloadable</a> operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>+A</code> is exactly the same as <code>A.unaryPlus()</code> where <code>unaryPlus</code> is a valid operator function available in the current scope.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">No additional restrictions apply.</span></p>
</div>
<h4 id="logical-not-expression">Logical not expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>logical not</em> expression is an expression which uses the prefix operator <code>!</code>. </span><span class="sentence">It is an <a href="#overloadable-operators">overloadable</a> operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>!A</code> is exactly the same as <code>A.not()</code> where <code>not</code> is a valid operator function available in the current scope.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">No additional restrictions apply.</span></p>
</div>
<h3 id="postfix-operator-expressions">Postfix operator expressions</h3>
<div id="grammar-rule-postfixUnaryExpression-pasted-49" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em><br />
| (<em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em> (<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em> {<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em>}))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnarySuffix-pasted-50" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-postfixUnaryOperator">postfixUnaryOperator</a></em><br />
| <em><a href="#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="#grammar-rule-callSuffix">callSuffix</a></em><br />
| <em><a href="#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnaryOperator-pasted-51" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'++'</code><br />
| <code>'--'</code><br />
| (<em><a href="#grammar-rule-EXCL_NO_WS">EXCL_NO_WS</a></em> <em><a href="#grammar-rule-excl">excl</a></em>)</span>
</dd>
</dl>
</div>
<h4 id="postfix-increment-expression">Postfix increment expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>postfix increment</em> expression is an expression which uses the postfix form of operator <code>++</code>. </span><span class="sentence">It is an <a href="#overloadable-operators">overloadable</a> operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>A++</code> is exactly the same as <code>val $freshId = A; A = A.inc(); $freshId</code> where <code>inc</code> is a valid operator function available in the current scope.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, <code>A++</code> stores the value of A to a temporary variable, assigns the result of <code>A.inc()</code> to <code>A</code> and then returns the temporary variable as the result.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">For a postfix increment expression <code>A++</code> expression <code>A</code> must be [assignable expressions][Assignable expressions]. </span><span class="sentence">Otherwise, it is a compile-time error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A postfix increment expression has the same type as the return type of the corresponding <code>inc</code> overload variant.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as the result of <code>inc</code> is assigned to <code>A</code>, the return type of <code>inc</code> must be a subtype of <code>A</code>.</span></p>
</div>
</blockquote>
<h4 id="postfix-decrement-expression">Postfix decrement expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>postfix decrement</em> expression is an expression which uses the postfix form of operator <code>--</code>. </span><span class="sentence">It is an <a href="#overloadable-operators">overloadable</a> operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>A--</code> is exactly the same as <code>val $freshId = A; A = A.dec(); $freshId</code> where <code>dec</code> is a valid operator function available in the current scope.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, <code>A--</code> stores the value of A to a temporary variable, assigns the result of <code>A.dec()</code> to <code>A</code> and then returns the temporary variable as the result.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">For a postfix decrement expression <code>A--</code> expression <code>A</code> must be [assignable expressions][Assignable expressions]. </span><span class="sentence">Otherwise, it is a compile-time error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A postfix decrement expression has the same type as the return type of the corresponding <code>dec</code> overload variant.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as the result of <code>dec</code> is assigned to <code>A</code>, the return type of <code>dec</code> must be a subtype of <code>A</code>.</span></p>
</div>
</blockquote>
<h3 id="not-null-assertion-expression">Not-null assertion expression</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(We need to define what â€œevaluationâ€ is)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>not-null assertion expression</em> is a postfix expression which uses an operator <code>!!</code>. </span><span class="sentence">For an expression <code>e!!</code>, if the type of <code>e</code> is nullable, a not-null assertion expression checks, whether the evaluation result of <code>e</code> is equal to <code>null</code> and, if it is, throws a runtime exception. </span><span class="sentence">If the evaluation result of <code>e</code> is not equal to <code>null</code>, the result of <code>e!!</code> is the evaluation result of <code>e</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If the type of <code>e</code> is non-nullable, not-null assertion expression <code>e!!</code> has no effect.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of non-null assertion expression is the <a href="#nullable-types">non-nullable</a> variant of the type of <code>e</code>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this type may be non-denotable in Kotlin and, as such, may be [approximated][Type approximation] in some situations with the help of <a href="#type-inference">type inference</a>.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Example)</span></p>
</div>
</div>
<h3 id="indexing-expressions">Indexing expressions</h3>
<div id="grammar-rule-postfixUnaryExpression-pasted-52" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em><br />
| (<em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em> (<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em> {<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em>}))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnarySuffix-pasted-53" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-postfixUnaryOperator">postfixUnaryOperator</a></em><br />
| <em><a href="#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="#grammar-rule-callSuffix">callSuffix</a></em><br />
| <em><a href="#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-indexingSuffix-pasted-54" class="grammar-rule">
<dl>
<dt><strong><em>indexingSuffix</em>:</strong></dt>
<dd><span class="sentence"><code>'['</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>']'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>indexing expression</em> is a suffix expression which uses one or more subexpression as <em>indices</em> between square brackets (<code>[</code> and <code>]</code>).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It is an <a href="#overloadable-operators">overloadable</a> operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A[I_0,I_1,\ldots,I_N]\)</span> is exactly the same as <span class="math inline">\(A\text{.get}(I_0,I_1,\ldots,I_N)\)</span>, where <code>get</code> is a valid operator function available in the current scope.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">An indexing expression has the same type as the corresponding <code>get</code> expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Indexing expressions are [assignable][Assignable expressions]. </span><span class="sentence">For a corresponding assignment form, see [indexing assignment][Indexing assignment].</span></p>
</div>
<h3 id="call-and-property-access-expressions">Call and property access expressions</h3>
<div id="grammar-rule-postfixUnaryExpression-pasted-55" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em><br />
| (<em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em> (<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em> {<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em>}))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnarySuffix-pasted-56" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-postfixUnaryOperator">postfixUnaryOperator</a></em><br />
| <em><a href="#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="#grammar-rule-callSuffix">callSuffix</a></em><br />
| <em><a href="#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-navigationSuffix-pasted-57" class="grammar-rule">
<dl>
<dt><strong><em>navigationSuffix</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-memberAccessOperator">memberAccessOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> | <em><a href="#grammar-rule-parenthesizedExpression">parenthesizedExpression</a></em> | <code>'class'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-callSuffix-pasted-58" class="grammar-rule">
<dl>
<dt><strong><em>callSuffix</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-typeArguments">typeArguments</a></em>] [<em><a href="#grammar-rule-valueArguments">valueArguments</a></em>] <em><a href="#grammar-rule-annotatedLambda">annotatedLambda</a></em>)<br />
| ([<em><a href="#grammar-rule-typeArguments">typeArguments</a></em>] <em><a href="#grammar-rule-valueArguments">valueArguments</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-annotatedLambda-pasted-59" class="grammar-rule">
<dl>
<dt><strong><em>annotatedLambda</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-annotation">annotation</a></em>} [<em><a href="#grammar-rule-label">label</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-lambdaLiteral">lambdaLiteral</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-valueArguments-pasted-60" class="grammar-rule">
<dl>
<dt><strong><em>valueArguments</em>:</strong></dt>
<dd><span class="sentence">(<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)<br />
| (<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArgument">valueArgument</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArgument">valueArgument</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeArguments-pasted-61" class="grammar-rule">
<dl>
<dt><strong><em>typeArguments</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-typeProjection">typeProjection</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeProjection">typeProjection</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'&gt;'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjection-pasted-62" class="grammar-rule">
<dl>
<dt><strong><em>typeProjection</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-typeProjectionModifiers">typeProjectionModifiers</a></em>] <em><a href="#grammar-rule-type">type</a></em>)<br />
| <code>'*'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjectionModifiers-pasted-63" class="grammar-rule">
<dl>
<dt><strong><em>typeProjectionModifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-typeProjectionModifier">typeProjectionModifier</a></em> {<em><a href="#grammar-rule-typeProjectionModifier">typeProjectionModifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-memberAccessOperator-pasted-64" class="grammar-rule">
<dl>
<dt><strong><em>memberAccessOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'.'</code><br />
| <em><a href="#grammar-rule-safeNav">safeNav</a></em><br />
| <code>'::'</code></span>
</dd>
</dl>
</div>
<h4 id="navigation-operators">Navigation operators</h4>
<div class="paragraph">
<p><span class="sentence">Expressions which use the navigation binary operators (<code>.</code>, <code>.?</code> or <code>::</code>) are syntactically similar, but, in fact, may have very different semantics.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>a.c</code> may have one of the following semantics when used as an expression:</span></p>
</div>
<ul>
<li><div class="paragraph">
<p><span class="sentence">A fully-qualified type, property or object name. </span><span class="sentence">The left side of <code>.</code> must be a package name, while the right side corresponds to a declaration in that package.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: qualification uses operator <code>.</code> only.</span></p>
</div>
</blockquote></li>
<li><span class="sentence">A property access. </span><span class="sentence">Here <code>a</code> is a value available in the current scope and <code>c</code> is a property name.</span></li>
<li><div class="paragraph">
<p><span class="sentence">A function call if followed by the call suffix (arguments in parentheses). </span><span class="sentence">Here <code>a</code> is a value available in the current scope and <code>c</code> is a function name. </span><span class="sentence">These expressions follow the <a href="#overload-resolution">overloading</a> rules.</span></p>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence"><code>a::c</code> may have one of the following semantics when used as an expression:</span></p>
</div>
<ul>
<li><span class="sentence">A [property reference][Callable references]. </span><span class="sentence">Here <code>a</code> may be either a value available in the current scope or a type name, and <code>c</code> is a property name.</span></li>
<li><span class="sentence">A [function reference][Callable references]. </span><span class="sentence">Here <code>a</code> may be either a value available in the current scope or a type name, and <code>c</code> is a function name.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence"><code>a?.c</code> is a <em>safe navigation</em> operator, which has the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>a?.c</code> is exactly the same as <code>if (a != null) a.c else null</code>.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means the type of <code>a?.c</code> is the <a href="#nullable-types">nullable</a> variant of the type of <code>a.c</code>.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Identifiers, paths, that kinda stuff)</span></p>
</div>
</div>
<h3 id="function-literals">Function literals</h3>
<div class="paragraph">
<p><span class="sentence">Kotlin supports using functions as values. </span><span class="sentence">This includes, among other things, being able to use named functions (via [function references][Callable references]) as parts of expressions. </span><span class="sentence">Sometimes it does not make much sense to provide a separate function declaration, but rather define a function in-place. </span><span class="sentence">This is implemented using <em>function literals</em>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two types of function literals in Kotlin: <em>lambda literals</em> and <em>anonymous function declarations</em>. </span><span class="sentence">Both of these provide a way of defining a function in-place, but have subtle differences.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as some may consider function literals to be closely related to function declarations, [here][Function declarations] is the corresponding section of the specification.</span></p>
</div>
</blockquote>
<h4 id="anonymous-function-declarations">Anonymous function declarations</h4>
<div id="grammar-rule-anonymousFunction-pasted-65" class="grammar-rule">
<dl>
<dt><strong><em>anonymousFunction</em>:</strong></dt>
<dd><span class="sentence"><code>'fun'</code><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-functionValueParameters">functionValueParameters</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionBody">functionBody</a></em>]</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Anonymous function declarations</em>, despite their name, are not declarations per se, but rather expressions which resemble function declarations. </span><span class="sentence">They have a syntax very similar to function declarations, with the following key differences:</span></p>
</div>
<ul>
<li><span class="sentence">Anonymous functions do not have a name;</span></li>
<li><span class="sentence">Anonymous functions may not have type parameters;</span></li>
<li><span class="sentence">Anonymous functions may not have default parameters;</span></li>
<li><span class="sentence">Anonymous functions may have variable argument parameters, but they are automatically decayed to non-variable argument parameters of the corresponding array type <span><span class="TODO">(TODO(how does this really work?))</span><span class="TODO-marker">*</span></span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Anonymous function declaration may declare an anonymous extension function.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as anonymous functions may not have type parameters, you cannot declare an anonymous extension function on a parameterized receiver type.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The type of an anonymous function declaration is the function type constructed similarly to a [named function declaration][Function declarations].</span></p>
</div>
<h4 id="lambda-literals">Lambda literals</h4>
<div id="grammar-rule-lambdaLiteral-pasted-66" class="grammar-rule">
<dl>
<dt><strong><em>lambdaLiteral</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-LCURL">LCURL</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-statements">statements</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-RCURL">RCURL</a></em>)<br />
| (<em><a href="#grammar-rule-LCURL">LCURL</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-lambdaParameters">lambdaParameters</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-ARROW">ARROW</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-statements">statements</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'}'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaParameters-pasted-67" class="grammar-rule">
<dl>
<dt><strong><em>lambdaParameters</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-lambdaParameter">lambdaParameter</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-COMMA">COMMA</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-lambdaParameter">lambdaParameter</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaParameter-pasted-68" class="grammar-rule">
<dl>
<dt><strong><em>lambdaParameter</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em><br />
| (<em><a href="#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-COLON">COLON</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>])</span>
</dd>
</dl>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(This funking section)</span></p>
</div>
</div>
<h3 id="object-literals">Object literals</h3>
<div id="grammar-rule-objectLiteral-pasted-69" class="grammar-rule">
<dl>
<dt><strong><em>objectLiteral</em>:</strong></dt>
<dd><span class="sentence">(<code>'object'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>])<br />
| (<code>'object'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>)</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Object literals are used to define anonymous objects in Kotlin. </span><span class="sentence">Anonymous objects are similar to regular objects, but they (obviously) have no name and thus can be used only as expressions. </span><span class="sentence">Anonymous objects, just like regular object declarations, can have at most one base class and zero or more base interfaces declared in its supertype specifiers.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The main difference between the regular object declaration and an anonymous object is its type. </span><span class="sentence">The type of an anonymous object is a special kind of type which is usable (and visible) only in the scope where it is declared. </span><span class="sentence">It is similar to a type of a regular object declaration, but, as it cannot be used outside the scope, with some interesting effects.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When a value of an anonymous object type escapes current scope:</span></p>
</div>
<ul>
<li><span class="sentence">If the type has only one declared supertype, it is implicitly downcasted to this declared supertype;</span></li>
<li><span class="sentence">If the type has several declared supertypes, there must be an implicit or explicit cast to any suitable type visible outside the scope, otherwise it is a compile-time error.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: an implicit cast may arise, for example, from the results of the type inference.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: in this context â€œescapingâ€ current scope is performed immediately if the corresponding value is declared as a global- or classifier-scope property, as those are a part of package interface.</span></p>
</div>
</blockquote>
<h3 id="this-expressions">This-expressions</h3>
<div id="grammar-rule-thisExpression-pasted-70" class="grammar-rule">
<dl>
<dt><strong><em>thisExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'this'</code><br />
| <em><a href="#grammar-rule-THIS_AT">THIS_AT</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">This-expressions are special kind of expressions used to access <a href="#receivers">receivers</a> available in current scope. </span><span class="sentence">The basic form of this expression, denoted by <code>this</code> keyword, is used to access the current implicit receiver according to the receiver overloading rules. </span><span class="sentence">In order to access other receivers, labeled <code>this</code> expressions are used. </span><span class="sentence">These may be any of the following:</span></p>
</div>
<ul>
<li><span class="sentence"><code>this@type</code>, where <code>type</code> is a name of any classifier currently being declared (that is, this-expression is located in the inner scope of the classifier declaration), refers to the implicit object of the type being declared;</span></li>
<li><span class="sentence"><code>this@function</code>, where <code>function</code> is a name of any extension function currently being declared (that is, this-expression is located in the function body), refers to the implicit receiver object of the extension function.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Any other form of this-expression is illegal and must be a compile-time error.</span></p>
</div>
<h3 id="super-forms">Super-forms</h3>
<div id="grammar-rule-superExpression-pasted-71" class="grammar-rule">
<dl>
<dt><strong><em>superExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'super'</code> [<code>'&lt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'&gt;'</code>] [<code>'@'</code> <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em>])<br />
| <em><a href="#grammar-rule-SUPER_AT">SUPER_AT</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Super-forms are special kind of expression which can only be used as receivers in a function or property access expression. </span><span class="sentence">Any use of super-form expression in any other context is a compile-time error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Super-forms are used in classifier declarations to access method implementations from the supertypes without invoking overriding behaviour.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(The restâ€¦)</span></p>
</div>
</div>
<h3 id="jump-expressions">Jump expressions</h3>
<div id="grammar-rule-jumpExpression-pasted-72" class="grammar-rule">
<dl>
<dt><strong><em>jumpExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'throw'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)<br />
| ((<code>'return'</code> | <em><a href="#grammar-rule-RETURN_AT">RETURN_AT</a></em>) [<em><a href="#grammar-rule-expression">expression</a></em>])<br />
| <code>'continue'</code><br />
| <em><a href="#grammar-rule-CONTINUE_AT">CONTINUE_AT</a></em><br />
| <code>'break'</code><br />
| <em><a href="#grammar-rule-BREAK_AT">BREAK_AT</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Jump expressions</em> are expressions which redirect the evaluation of the program to a different program point. </span><span class="sentence">All these expressions have several things in common:</span></p>
</div>
<ul>
<li><span class="sentence">They all have type <a href="#kotlin.nothing"><code>kotlin.Nothing</code></a>, meaning that they never produce any runtime value;</span></li>
<li><span class="sentence">Any code which follows such expressions is never evaluated.</span></li>
</ul>
<h4 id="throw-expressions">Throw expressions</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<a href="#exceptions">Exceptions</a> go first)</span></p>
</div>
</div>
<h4 id="return-expressions">Return expressions</h4>
<div class="paragraph">
<p><span class="sentence">A <em>return expression</em>, when used inside a function body, immediately stops evaluating the current function and returns to its caller, effectively making the function call expression evaluate to the value specified in this return expression (if any). </span><span class="sentence">A return expression with no value implicitly returns the <code>kotlin.Unit</code> object.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two forms of return expression: a simple return expression, specified using the <code>return</code> keyword, which returns from the innermost <a href="#function-declaration">function declaration</a> (or [anonymous function expression][Anonymous function expression]) and a labeled return expression of the form <code>return@Context</code> where <code>Context</code> may be one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">The name of one of the enclosing function declarations, which refers to this function. </span><span class="sentence">If several declarations match one name, it is a compile-time error;</span></li>
<li><span class="sentence">If <code>return@Context</code> is inside a lambda expression body, the name of the function <strong>using</strong> this lambda expression as its argument may be used as <code>Context</code> to refer to the lambda literal itself.</span></li>
<li><div class="TODO">
<span class="sentence">TODO(return from a labeled lambda)</span>
</div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: these rules mean that a simple return expression inside a lambda expression returns <strong>from the innermost function</strong>, in which this lambda expression is defined.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">If returning from the referred function is allowed in the current context, the return is performed as usual. </span><span class="sentence">If returning from the referred function is not allowed, it is a compile-time error.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(What does it mean for returns to be disallowed?)</span></p>
</div>
</div>
<h4 id="continue-expression">Continue expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>continue expression</em> is a jump expression allowed only within loop bodies. </span><span class="sentence">When evaluated, this expression passes the control to the start of the next loop iteration (aka â€œcontinue-jumpsâ€).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two forms of continue expressions:</span></p>
</div>
<ul>
<li><span class="sentence">A simple continue expression, specified using the <code>continue</code> keyword, which continue-jumps to the innermost loop statement in the current scope;</span></li>
<li><span class="sentence">A labeled continue expression, denoted <code>continue@Loop</code>, where <code>Loop</code> is a label of a labeled loop statement <code>L</code>, which continue-jumps to the loop <code>L</code>.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Future use: as of Kotlin 1.2.60, a simple continue expression is not allowed inside when expressions.</span></p>
</div>
</blockquote>
<h4 id="break-expression">Break expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>break expression</em> is a jump expression allowed only within loop bodies. </span><span class="sentence">When evaluated, this expression passes the control to the next program point immediately after the loop (aka â€œbreak-jumpsâ€).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two forms of break expressions:</span></p>
</div>
<ul>
<li><span class="sentence">A simple break expression, specified using the <code>break</code> keyword, which break-jumps to the innermost loop statement in the current scope;</span></li>
<li><span class="sentence">A labeled break expression, denoted <code>break@Loop</code>, where <code>Loop</code> is a label of a labeled loop statement <code>L</code>, which break-jumps to the loop <code>L</code>.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Future use: as of Kotlin 1.2.60, a simple break expression is not allowed inside when expressions.</span></p>
</div>
</blockquote>
<h3 id="string-interpolation-expressions">String interpolation expressions</h3>
<div id="grammar-rule-stringLiteral-pasted-73" class="grammar-rule">
<dl>
<dt><strong><em>stringLiteral</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-lineStringLiteral">lineStringLiteral</a></em><br />
| <em><a href="#grammar-rule-multiLineStringLiteral">multiLineStringLiteral</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-lineStringLiteral-pasted-74" class="grammar-rule">
<dl>
<dt><strong><em>lineStringLiteral</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-QUOTE_OPEN">QUOTE_OPEN</a></em> {<em><a href="#grammar-rule-lineStringContent">lineStringContent</a></em> | <em><a href="#grammar-rule-lineStringExpression">lineStringExpression</a></em>} <em><a href="#grammar-rule-QUOTE_CLOSE">QUOTE_CLOSE</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiLineStringLiteral-pasted-75" class="grammar-rule">
<dl>
<dt><strong><em>multiLineStringLiteral</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-TRIPLE_QUOTE_OPEN">TRIPLE_QUOTE_OPEN</a></em> {<em><a href="#grammar-rule-multiLineStringContent">multiLineStringContent</a></em> | <em><a href="#grammar-rule-multiLineStringExpression">multiLineStringExpression</a></em> | <em><a href="#grammar-rule-MultiLineStringQuote">MultiLineStringQuote</a></em>} <em><a href="#grammar-rule-TRIPLE_QUOTE_CLOSE">TRIPLE_QUOTE_CLOSE</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-lineStringContent-pasted-76" class="grammar-rule">
<dl>
<dt><strong><em>lineStringContent</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-LineStrText">LineStrText</a></em><br />
| <em><a href="#grammar-rule-LineStrEscapedChar">LineStrEscapedChar</a></em><br />
| <em><a href="#grammar-rule-LineStrRef">LineStrRef</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-lineStringExpression-pasted-77" class="grammar-rule">
<dl>
<dt><strong><em>lineStringExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-LineStrExprStart">LineStrExprStart</a></em> <em><a href="#grammar-rule-expression">expression</a></em> <code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiLineStringContent-pasted-78" class="grammar-rule">
<dl>
<dt><strong><em>multiLineStringContent</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-MultiLineStrText">MultiLineStrText</a></em><br />
| <em><a href="#grammar-rule-MultiLineStringQuote">MultiLineStringQuote</a></em><br />
| <em><a href="#grammar-rule-MultiLineStrRef">MultiLineStrRef</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiLineStringExpression-pasted-79" class="grammar-rule">
<dl>
<dt><strong><em>multiLineStringExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-MultiLineStrExprStart">MultiLineStrExprStart</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>String interpolation expressions</em> replace the traditional string literals found in some other languages and supersede them. </span><span class="sentence">A string interpolation expression consists of one or more fragments of two different kinds: string content fragments (raw pieces of string content found inside the quoted literal) and <em>interpolated expressions</em>, delimited by the special syntax using the <code>$</code> symbol. </span><span class="sentence">This syntax allows to specify such fragments by directly following the <code>$</code> symbol with either a single identifier (if the expression is a single identifier) or a CSB. </span><span class="sentence">In either case, the interpolated value is evaluated and converted into a <code>kotlin.String</code> by a process defined below. </span><span class="sentence">The resulting value of a string interpolation expression is the joining of all fragments in the expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An interpolated value <span class="math inline">\(v\)</span> is converted to <code>kotlin.String</code> according to the following convention:</span></p>
</div>
<ul>
<li><span class="sentence">If it is equal to the <a href="#null-literal">null reference</a>, the result is <code>&quot;null&quot;</code>;</span></li>
<li><span class="sentence">Otherwise, the result is <span class="math inline">\(v\)</span><code>.toString()</code> where <code>toString</code> is the <code>kotlin.Any</code> member function.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">There are two kinds of string interpolation expressions: line interpolation expressions and multiline (or raw) interpolation expressions. </span><span class="sentence">The difference is that some symbols (namely, newline symbols) are not allowed to be used inside line interpolation expressions and they need to be escaped (see <a href="#grammar">grammar</a> for details). </span><span class="sentence">On the other hand, multiline interpolation expressions allow such symbols inside them, but do not allow single character escaping of any kind.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: among other things, this means that the escaping of the <code>$</code> symbol is impossible in multiline strings. </span><span class="sentence">If you need an escaped <code>$</code> symbol, use an interpolation fragment instead</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">String interpolation expression always has type <code>kotlin.String</code>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(define this using actual <code>kotlin.StringBuilder</code> business?)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(list all the allowed escapes here?)</span></p>
</div>
</div>
<h3 id="operator-expressions">Operator expressions</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h2 id="todos">TODOs()</h2>
<ul>
<li><span class="sentence">String interpolation</span></li>
<li><span class="sentence">Overloadable operators &amp;&amp; operator expansion</span></li>
<li><span class="sentence">Smart casts vs compile-time types</span></li>
<li><span class="sentence">What does <code>decaying</code> for vararg actually mean?</span></li>
<li><span class="sentence">Where to define spread operator?</span></li>
<li><span class="sentence">Object literal types look just like restricted union types. </span><span class="sentence">Are there any traps hidden here?</span></li>
<li><span class="sentence">The last paragraph in <a href="#object-literals">object literals</a> is also pretty shady</span></li>
</ul>
<h2 id="order-of-evaluation">Order of evaluation</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h2 id="semantics">Semantics</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h2 id="control--and-data-flow-analysis">Control- and data-flow analysis</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h2 id="kotlin-type-constraints">Kotlin type constraints</h2>
<div class="paragraph">
<p><span class="sentence">Some complex tasks that need to be solved when compiling Kotlin code are formulated best using <em>constraint systems</em> on Kotlin types. </span><span class="sentence">These are solved using constraint solvers.</span></p>
</div>
<h3 id="type-constraint-definition">Type constraint definition</h3>
<div class="paragraph">
<p><span class="sentence">A <em>type constraint</em> in general is an inequation of the following form: <span class="math inline">\(T &lt;: U\)</span> where <span class="math inline">\(T\)</span> and <span class="math inline">\(U\)</span> are Kotlin types (see <a href="#type-system">type system</a>). </span><span class="sentence">It is important, however, that Kotlin has parameterized types and type parameters of <span class="math inline">\(T\)</span> and <span class="math inline">\(U\)</span> (or type parameters of their parameters, or <span class="math inline">\(T\)</span> and <span class="math inline">\(U\)</span> themselves) may be <em>type variables</em>, that are unknown types that may be substituted by any other type in Kotlin.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Please note that, in general, type variables of the constraint system are not the same as type parameters of a type or a callable. </span><span class="sentence">Some type parameters may be <em>bound</em> in the constraint system, meaning that, although they are not known yet in Kotlin code, they are not type variables and are not to be substituted.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When such an ambiguity arises, we will use the notation <span class="math inline">\(T_i\)</span> for a type variable and <span class="math inline">\(\tilde{T_i}\)</span> for a bound type parameter. </span><span class="sentence">The main difference between bound parameters and concrete types is that different concrete types may not be equal, but a bound parameter may be equal to another bound parameter or a concrete type.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Several examples of valid type constraints:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\mathtt{List}\left&lt;\tilde{X}\right&gt; &lt;: Y\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\mathtt{List}\left&lt;\tilde{X}\right&gt; &lt;: \mathtt{List}\left&lt;\mathtt{List}\left&lt;\mathtt{Int}\right&gt;\right&gt;\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\widetilde{X} &lt;: Y\)</span></span></li>
</ul>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Every constraint system has implicit constraints <span class="math inline">\(\mathtt{Any} &lt;: T_j\)</span> and <span class="math inline">\(T_j &lt;: \mathtt{Nothing?}\)</span> for every type <span class="math inline">\(T_j\)</span> mentioned in constraint, including type variables.</span></p>
</div>
<h3 id="type-constraint-solving">Type constraint solving</h3>
<div class="paragraph">
<p><span class="sentence">There are two tasks that a type constraint solver may perform: checking constraint system for soundness and solving the system, e.g.Â inferring values for all the type variables that have themselves no type variables in them.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Checking a constraint system for soundness can be viewed as a simpler case of solving a constraint, as if there is a solution, than the system is sound. </span><span class="sentence">It is, however, a much simpler task with only two possible outcomes. </span><span class="sentence">Solving a constraint system, on the other hand, may have several different results as there may be several valid solutions.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Constraint examples that are sound yet no relevant solutions exist:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(X &lt;: Y\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\mathtt{List}\left&lt;X\right&gt; &lt;: \mathtt{Collection}\left&lt;X\right&gt;\)</span></span></li>
</ul>
</blockquote>
<h4 id="checking-constraint-system-soundness">Checking constraint system soundness</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO?</span></p>
</div>
</div>
<h4 id="finding-optimal-solution">Finding optimal solution</h4>
<div class="paragraph">
<p><span class="sentence">As any constraint system may have several valid solutions, finding one that is â€œoptimalâ€ in some sense is not possible in general, because the notion of the best solution for a task depends on a particular use-case. </span><span class="sentence">To solve this problem, the constraint system allows two additional types of constraints:</span></p>
</div>
<ul>
<li><span class="sentence">A pull-up constraint for type variable <span class="math inline">\(T\)</span>, denoted <span class="math inline">\(\uparrow T\)</span>, signifying that when finding a substitution for this variable, the optimal solution is the least one according to subtyping relation;</span></li>
<li><span class="sentence">A push-down constraint for type variable <span class="math inline">\(T\)</span>, denoted <span class="math inline">\(\downarrow T\)</span>, signifying that when finding a substitution for this variable, the optimal solution is the biggest one according to subtyping relation.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If a variable have no constraints of these two kinds associated with it, it is assumed to have a pull-up constraint, that is, in an ambigious situation, the biggest possible type is chosen.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO?</span></p>
</div>
</div>
<h2 id="type-inference">Type inference</h2>
<div class="paragraph">
<p><span class="sentence">Kotlin has a concept of <em>type inference</em> for compile-time type information, meaning that some type information in the code may be omitted, to be inferred by the compiler. </span><span class="sentence">Type inference is a <a href="#kotlin-type-constraints">type constraint</a> problem, solved by the type constraint solver.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two kinds of type inference supported by kotlin:</span></p>
</div>
<ul>
<li><span class="sentence">Local type inference, inferring types of expressions locally, in statement scope;</span></li>
<li><span class="sentence">Function signature type inference, inferring types for function return values and/or parameters.</span></li>
</ul>
<h3 id="smart-casts">Smart casts</h3>
<div class="paragraph">
<p><span class="sentence">Kotlin introduces a limited form of flow-dependent typing called <em>smart casting</em>. </span><span class="sentence">Flow-dependent typing means that some statements in the program may introduce changes to the compile-time types of properties. </span><span class="sentence">This allows to avoid unnecessary casting of these values in cases where the runtime types are guaranteed to conform to expected compile-time types.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Smart casting is dependent on the <em>smart cast conditions</em> that are boolean predicates about program values. </span><span class="sentence">If some condition involving a program value <em>dominates</em> some program scope, the type of this value is mutated inside that scope.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two kinds of smart cast conditions: nullity conditions and type conditions. </span><span class="sentence">Nullity conditions signify that some value is not nullable, e.g.Â itâ€™s value is guaranteed to not be <code>null</code>. </span><span class="sentence">Type conditions signify that some valueâ€™s runtime type conforms to a constraint of <span class="math inline">\(RT &lt;: T\)</span> where <span class="math inline">\(T\)</span> is the assumed type and <span class="math inline">\(RT\)</span> is the runtime type.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Nullity conditions may be viewed as a subcase of type conditions with assumed type <code>kotlin.Any</code></span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">There are also negated forms of both conditions that do not affect the typing in any way, but may be negated again to introduce non-negated forms of the same conditions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The actual compile type of a value that is subject of smart casting (see below) for any purpose (including, but not limited to, function overloading and further type inference of other values) if it is dominated by a smart casting condition, is, for every condition:</span></p>
</div>
<ul>
<li><span class="sentence">If the condition is a nullability condition, the <a href="#type-intersection">intersection</a> of the type it had before (including the results of smart casting performed for other conditions) and type <code>kotlin.Any</code>;</span></li>
<li><span class="sentence">If the condition is a type condition, the <a href="#type-intersection">intersection</a> of the type it had before (including the results of smart casting performed for other conditions) and the assumed type of the condition.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The following values are subject to smart casting:</span></p>
</div>
<ul>
<li><span class="sentence">Immutable local or classifier-scope properties without delegation or custom getters;</span></li>
<li><span class="sentence">Immutable properties of other such properties that too do not have delegation or custom getters;</span></li>
<li><span class="sentence">Mutable local properties without delegation or custom getters as soon as the compiler can prove that they cannot be mutated by external means:</span>
<ul>
<li><span class="sentence">Any properties that are captured in non-inlining lambda expressions or anonymous objects are not applicable.</span></li>
</ul></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(): the rest is really shaky</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Smart casting conditions are introduced by:</span></p>
</div>
<ul>
<li><span class="sentence">Conditional expressions (<code>if</code> and <code>when</code>):</span>
<ul>
<li><span class="sentence">Smart cast conditions derived from expression condition are active inside the positive branch scope;</span></li>
<li><span class="sentence">Smart cast conditions derived from negated expression condition are active inside the negative branch scope;</span></li>
<li><span class="sentence">If all the branches except one are unreachable, that branchâ€™s condition is also propagated over to the scope containing the conditional expression, after the conditional expression;</span></li>
</ul></li>
<li><span class="sentence">Elvis operator (operator <code>?:</code>): if the right-hand branch of elvis operator is unreachable, a nullability condition for the left-hand side expression (if applicable) is introduced for the rest of the containing scope;</span></li>
<li><span class="sentence">Logical conjunction expressions (operator <code>&amp;&amp;</code>): all conditions derived from left-hand expression are applied to the right-hand expression;</span></li>
<li><span class="sentence">Logical disjunction expressions (operator <code>||</code>): all condtions derived from left-hand expression are applied negated to the right-hand expression;</span></li>
<li><span class="sentence">Not-null assertion expressions (operator <code>!!</code>): the left-hand side value (if applicable) introduces a nullability condtion for the rest of the scope the expression is contained in;</span></li>
<li><span class="sentence">Direct casting expression (operator <code>as</code>): the left-hand side expression (if applicable) introduces a type condition for the rest of the scope the expression is contained in with the assumed type being the same as the right-hand side type of the casting expression;</span></li>
<li><span class="sentence">Direct assignments: if both sides of the assignment are applicable expressions, all the conditions currently applying to the right-hand side are also applied to the left-hand side of the assignment for the rest of the containing scope;</span></li>
<li><span class="sentence">Platform-specific cases: different platforms may add other kinds of expressions that introduce smart-casting conditions.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Property declarations are not listed here because their types are naturally derived from initializers</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Smart cast conditions are derived from boolean expressions in the following way:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>is</code><span class="math inline">\(T\)</span> where <span class="math inline">\(x\)</span> is an applicable expression implies a type condition for <span class="math inline">\(x\)</span> with assumed type <span class="math inline">\(T\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>!is</code><span class="math inline">\(T\)</span> where <span class="math inline">\(x\)</span> is an applicable expression implies a negated type condition for <span class="math inline">\(x\)</span> with assumed type <span class="math inline">\(T\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>== null</code> (or reversed) where <span class="math inline">\(x\)</span> is an applicable expression implies a a nullability condition for <span class="math inline">\(x\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>!= null</code> (or reversed) where <span class="math inline">\(x\)</span> is an applicable expression implies a a negated nullability condition for <span class="math inline">\(x\)</span>;</span></li>
<li><span class="sentence"><code>!</code><span class="math inline">\(x\)</span> where <span class="math inline">\(x\)</span> implies all the conditions implied by <span class="math inline">\(x\)</span>, but in negated form;</span></li>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>&amp;&amp;</code><span class="math inline">\(y\)</span> implies all the non-negated conditions implied by <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> and the intersection of all the negated conditions implied by <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>||</code><span class="math inline">\(y\)</span> implies all the negated conditions implied by <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> and the intersection of all the non-negated conditions implied by <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(x\)</span><code>==</code><span class="math inline">\(y\)</span> (or reversed) where <span class="math inline">\(x\)</span> is an applicable expression and <span class="math inline">\(y\)</span> is a known non-nullable value (that is, has a non-nullable compile-time type) implies the nullability condition for <span class="math inline">\(x\)</span>.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(): is there more than that?</span></p>
</div>
</div>
<h3 id="local-type-inference">Local type inference</h3>
<div class="paragraph">
<p><span class="sentence">Local type inference in Kotlin is the process of deducing the compile-time types of expressions, lambda expression parameters and properties. </span><span class="sentence">As already mentioned above, type inference is a <a href="#kotlin-type-constraints">type constraint</a> problem, solved by the type constraint solver.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In addition to the types of intermediate expressions, local type inference also must perform deduction and substitution for generic type parameters of functions and types involved in every expression. </span><span class="sentence">You can use the <a href="#expressions">expressions</a> part of this document as a reference point on how the types for different expressions are constructed (please note the effects of <a href="#smart-casts">smart casting</a> that are not mentioned in that part).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It does, however, need some clarification as those types are given as definitions, not as type constraints:</span></p>
</div>
<ul>
<li><span class="sentence">If the type <span class="math inline">\(T\)</span> is described as the least upper bound of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, it gets promoted to a pair of constraints: <span class="math inline">\(A &lt;: T\)</span> and <span class="math inline">\(B &lt;: T\)</span>;</span></li>
<li><div class="TODO">
<span class="sentence">TODO: are there other cases?)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Type inference in kotlin is also a bidirectional process, meaning that types of expressions may not only be derived from their arguments, but their usage as well. </span><span class="sentence">Please note that, albeit bidirectional, this process is still local, meaning that it processes one statement at a time, in the order of appearance in a scope, so a type of property in statement <span class="math inline">\(S_1\)</span> that goes before statement <span class="math inline">\(S_2\)</span> cannot be inferred based on usage information from <span class="math inline">\(S_2\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Unlike checking satisfiability for a type constraint system, actually solving it is not a definite process, as there may be more than one valid solution (see <a href="#type-constraint-solving">type constraint solving</a>). </span><span class="sentence">This means, among other things, that type inference in general may have several valid solutions as well. </span><span class="sentence">In particular, one may always derive a system <span class="math inline">\(A &lt;: T &lt;: B\)</span> for every type variable <span class="math inline">\(T\)</span> where <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are both valid solution types. </span><span class="sentence">One of these types is always the solution in Kotlin (although from the constraint viewpoint, there are usually more solutions available), but choosing between them is done according to special rules:</span></p>
</div>
<ul>
<li><div class="TODO">
<span class="sentence">TODO(): What are the rules?)</span>
</div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note that this is valid even if <span class="math inline">\(T\)</span> is a variable without any constraints, as every type in kotlin has an implicit constraint <span class="math inline">\(\mathtt{kotlin.Nothing} &lt;: T &lt;: \mathtt{kotlin.Any?}\)</span>.</span></p>
</div>
</blockquote>
<h3 id="todo-1">TODO</h3>
<ul>
<li><span class="sentence">Type approximation for public usage</span></li>
<li><span class="sentence">Ordering of lambdas (and ordering of overloading vs TI in general)</span></li>
</ul>
<h2 id="overload-resolution">Overload resolution</h2>
<div class="paragraph">
<p><span class="sentence">Kotlin supports <em>function overloading</em>, that is, the ability for several functions of the same name to coexist in the same scope, with the compiler picking the most suitable one when such a function is called. </span><span class="sentence">This section describes this mechanism in detail.</span></p>
</div>
<h3 id="intro">Intro</h3>
<div class="paragraph">
<p><span class="sentence">Unlike other object-oriented languages, Kotlin does not only have object methods, but also top-level functions, local functions, extension functions and function-like values, which complicate the overloading process quite a lot. </span><span class="sentence">Kotlin also has infix functions, operator and property overloading which all work in a similar, but subtly different way.</span></p>
</div>
<h3 id="receivers">Receivers</h3>
<div class="paragraph">
<p><span class="sentence">Every function or property that is defined as a method or an extension has one or more special parameters called <em>receiver</em> parameters. </span><span class="sentence">When calling such a callable using navigation operators (<code>.</code> or <code>?.</code>) the left hand side parameter is called an <em>explicit receiver</em> of this particular call. </span><span class="sentence">In addition to the explicit receiver, each call may indirectly access zero or more <em>implicit receivers</em>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Implicit receivers are available in some syntactic scope according to the following rules:</span></p>
</div>
<ul>
<li><span class="sentence">All receivers available in an outer scope are also available in the nested scope;</span></li>
<li><span class="sentence">In the scope of a classifier declaration, the following receivers are available:</span>
<ul>
<li><span class="sentence">The implicit <code>this</code> object of the declared type;</span></li>
<li><span class="sentence">The companion object (if one exists) of this class;</span></li>
<li><span class="sentence">The companion objects (if any exist) of all its superclasses;</span></li>
</ul></li>
<li><span class="sentence">If a function or a property is an extension, <code>this</code> parameter of the extension is also available inside the extension declaration;</span></li>
<li><span class="sentence">The scope of a lambda expression, if it has an extension function type, contains <code>this</code> argument of the lambda expression.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(If Iâ€™m a companion object, is a companion object of my supertype an implicit receiver for me or not?)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">The available receivers are prioritized in the following way:</span></p>
</div>
<ul>
<li><span class="sentence">The receivers provided in the most inner scope have higher priority;</span></li>
<li><span class="sentence">In a classifier body, the implicit <code>this</code> receiver has higher priority than any companion object receiver;</span></li>
<li><span class="sentence">Current class companion object receiver has higher priority than any of the base class companion objects.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The implicit receiver having the highest priority is also called the <em>default implicit receiver</em>. </span><span class="sentence">The default implicit receiver is available in the scope as <code>this</code>. </span><span class="sentence">Other available receivers may be accessed using <a href="#this-expressions">labeled this-expressions</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If an implicit receiver is available in a given scope, it may be used to call functions implicitely in that scope without using the navigation operator.</span></p>
</div>
<h3 id="the-forms-of-call-expression">The forms of call-expression</h3>
<div class="paragraph">
<p><span class="sentence">Any function in Kotlin may be called in several different ways:</span></p>
</div>
<ul>
<li><span class="sentence">A fully-qualified call: <code>package.foo()</code>;</span></li>
<li><span class="sentence">A call with an explicit receiver: <code>a.foo()</code>;</span></li>
<li><span class="sentence">An infix function call: <code>a foo b</code>;</span></li>
<li><span class="sentence">An overloaded operator call: <code>a + b</code>;</span></li>
<li><span class="sentence">A call without an explicit receiver: <code>foo()</code>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">For each of these cases, a compiler should first pick a number of <em>overload candidates</em>, which form a set of possibly intended callables (<em>overload candidate set</em>), and then <em>choose the most specific function</em> to call based on the types of the function and the call arguments.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: the overload candidates are picked <strong>before</strong> the most specific function is chosen.</span></p>
</div>
</blockquote>
<h3 id="callables-and-invoke-convention">Callables and <code>invoke</code> convention</h3>
<div class="paragraph">
<p><span class="sentence">A <em>callable</em> <span class="math inline">\(X\)</span> for the purpose of this section is one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">A function named <span class="math inline">\(X\)</span> at its declaration site;</span></li>
<li><span class="sentence">A property named <span class="math inline">\(X\)</span> at its declaration site with an operator function called <code>invoke</code> available as member or extension in the current scope.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">In the latter case a call <span class="math inline">\(X(Y_0,Y_1,\ldots,Y_N)\)</span> is an overloadable operator which is expanded to <span class="math inline">\(X\text{.invoke}(Y_0,Y_1,\ldots,Y_N)\)</span>. </span><span class="sentence">The call may contain type parameters, named parameters, variable argument parameter expansion and trailing lambda parameters, all of which are forwarded as-is to the corresponding <code>invoke</code> function.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>member callable</em> is either a member function or a member property with a member operator <code>invoke</code>. </span><span class="sentence">An <em>extension callable</em> is either an extension function, a member property with an extension operator <code>invoke</code> or an extension property with an extension operator <code>invoke</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When calculating overload candidate sets, member callables produce the following separate sets (ordered by higher priority first):</span></p>
</div>
<ul>
<li><span class="sentence">Member functions;</span></li>
<li><span class="sentence">Member properties.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Extension callables produce the following separate sets (ordered by higher priority first):</span></p>
</div>
<ul>
<li><span class="sentence">Extension functions;</span></li>
<li><span class="sentence">Member properties with extension invoke;</span></li>
<li><span class="sentence">Extension properties with member invoke;</span></li>
<li><span class="sentence">Extension properties with extension invoke.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Let us define this partition as c-level partition (callable-level partition). </span><span class="sentence">As this partition is the most fine-grained of all other steps of partitioning resolution candidates into sets, it is always performed last, after all other applicable steps.</span></p>
</div>
<h3 id="overload-resolution-for-a-fully-qualified-call">Overload resolution for a fully-qualified call</h3>
<div class="paragraph">
<p><span class="sentence">If a callable name is fully-qualified (that is, it contains a full package path), then the overload candidate set <span class="math inline">\(S\)</span> simply contains all the callables with the specified name in the specified package. </span><span class="sentence">As a package name can never clash with any other declared entity, after performing c-level partition on <span class="math inline">\(S\)</span>, the resulting sets are the only ones available for further processing.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Clear up this mess)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb19"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">package</span> <span class="im">a.b.c</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"></a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="kw">fun</span> <span class="fu">foo</span>(<span class="va">a</span>: <span class="dt">Int</span>) {}</a>
<a class="sourceLine" id="cb19-4" data-line-number="4"><span class="kw">fun</span> <span class="fu">foo</span>(<span class="va">a</span>: <span class="dt">Double</span>) {}</a>
<a class="sourceLine" id="cb19-5" data-line-number="5"><span class="kw">fun</span> <span class="fu">foo</span>(<span class="va">a</span>: <span class="dt">List</span>&lt;<span class="va">Char</span>&gt;) {}</a>
<a class="sourceLine" id="cb19-6" data-line-number="6"><span class="kw">val</span> <span class="va">foo</span> = {}</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">. . .</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">a.b.c.foo()</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">Here the resulting overload candidate set contains all the callables named <code>foo</code> from the package <code>a.b.c</code>.</span></p>
</div>
<h3 id="a-call-with-an-explicit-receiver">A call with an explicit receiver</h3>
<div class="paragraph">
<p><span class="sentence">If a function call is done via a <a href="#navigation-operators">navigation operator</a> (<code>.</code> or <code>?.</code>, not to be confused with a <a href="#overload-resolution-for-a-fully-qualified-call">fully-qualified call</a>), then the left hand side operand of the call is the explicit receiver of this call.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A call of callable <code>f</code> with an explicit receiver <code>e</code> is correct if one (or more) of the following holds:</span></p>
</div>
<ol type="1">
<li><span class="sentence"><code>f</code> is a member callable of the classifier type of <code>e</code> or any of its supertypes;</span></li>
<li><span class="sentence"><code>f</code> is an extension callable of the classifier type of <code>e</code> or any of its supertypes, including local and imported extensions.</span></li>
</ol>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: callables for case 2 include not only top-level extension callables, but also extension callables from any of the available implicit receivers. </span><span class="sentence">For example, if class <span class="math inline">\(P\)</span> contains a member extension function for another class <span class="math inline">\(T\)</span> and an object of class <span class="math inline">\(P\)</span> is available as an implicit receiver, this extension function may be used for the call if it has a suitable type.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">If a call is correct, for a callable named <code>f</code> with an explicit receiver <code>e</code> of type <code>T</code> the following sets are analyzed (in the given order):</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Sync with scopes and stuff when we have them)</span></p>
</div>
</div>
<ol type="1">
<li><span class="sentence">The sets of non-extension member callables named <code>f</code> of type <code>T</code>;</span></li>
<li><span class="sentence">The sets of local extension callables named <code>f</code>, whose receiver type conforms to type <code>T</code>, in all declaration scopes containing the current declaration scope, ordered by the size of the scope (smallest first), excluding the package scope;</span></li>
<li><span class="sentence">The sets of explicitly imported extension callables named <code>f</code>, whose receiver type conforms to type <code>T</code>;</span></li>
<li><span class="sentence">The sets of extension callables named <code>f</code>, whose receiver type conforms to type <code>T</code>, declared in the package scope;</span></li>
<li><span class="sentence">The sets of star-imported extension callables named <code>f</code>, whose receiver type conforms to type <code>T</code>;</span></li>
<li><span class="sentence">The sets of implicitly imported extension callables named <code>f</code>, whose receiver type conforms to type <code>T</code>.</span></li>
</ol>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: here type <code>U</code> conforms to type <code>T</code>, if <span class="math inline">\(T &lt;: U\)</span>.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(all these X-imported things need to be defined somewhere)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">When analyzing these sets, the <strong>first</strong> set that contains <strong>any</strong> callable with the corresponding name and conforming types is picked. </span><span class="sentence">This means, among other things, that if the set constructed on step 2 contains the overall most suitable candidate function, but the set constructed on step 1 is not empty, the functions from set 1 will be picked despite them being less suitable overload candidates.</span></p>
</div>
<h3 id="infix-function-calls">Infix function calls</h3>
<div class="paragraph">
<p><span class="sentence">Infix function calls are a special case of function calls with an explicit receiver in the left hand side position, i.e., <code>a foo b</code> may be an infix form of <code>a.foo(b)</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">However, there is an important difference: during the overload candidate set construction the only functions considered for inclusion are the ones with the <code>infix</code> modifier. </span><span class="sentence">All other functions (and any properties) are not even considered for inclusion. </span><span class="sentence">Aside from this difference, candidates are selected using the same rules as for normal calls with explicit receiver.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this also means that all properties available through the <code>invoke</code> convention are non-eligible for infix calls, as there is no way of specifying the <code>infix</code> modifier for them.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Different platform implementations may extend the set of functions considered as infix functions for the overload candidate set.</span></p>
</div>
<h3 id="operator-calls">Operator calls</h3>
<div class="paragraph">
<p><span class="sentence">According to TODO(), some operator expressions in Kotlin can be overloaded using specially-named functions. </span><span class="sentence">This makes operator expressions semantically equivalent to function calls with explicit receiver, where the receiver expression is selected based on the operator used (see TODO()). </span><span class="sentence">The selection of an exact function called in each particular case is based on the same rules as for function calls with explicit receivers, the only difference being that only functions with <code>operator</code> modifier are considered for inclusion when building overload candidate sets. </span><span class="sentence">Any properties are never considered for the overload candidate sets of operator calls.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this also means that all the properties available through the <code>invoke</code>convention are non-eligible for operator calls, as there is no way of specifying the <code>operator</code> modifier for them, even though the <code>invoke</code> callable is required to always have such modifier. </span><span class="sentence">As <code>invoke</code> convention itself is an operator call, it is impossible to use more than one <code>invoke</code> conventions in a single call.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Different platform implementations may extend the set of functions considered as operator functions for the overload candidate set.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: these rules are valid not only for dedicated operator expressions, but also for any calls arising from expanding <a href="#for-loop-statement"><code>for</code>-loop</a> iteration conventions, <a href="#assignments">assignments</a> or <a href="#delegated-property-declaration">property delegates</a>.</span></p>
</div>
</blockquote>
<h3 id="a-call-without-an-explicit-receiver">A call without an explicit receiver</h3>
<div class="paragraph">
<p><span class="sentence">A call which is performed with unqualified function name and without using a navigation operator is a call without an explicit receiver. </span><span class="sentence">It may have one or more implicit receivers or reference a top-level function.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">As with function calls with explicit receiver, we should first pick a valid overload candidate set and then search this set for the <em>most specific function</em> to match the call.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For a function named <code>f</code> the following sets are analyzed (in the given order):</span></p>
</div>
<ol type="1">
<li><span class="sentence">The sets of local non-extension functions named <code>f</code> available in the current scope, in order of the scope they are declared in, smallest scope first;</span></li>
<li><span class="sentence">The overload candidate sets for each implicit receiver <code>r</code> and <code>f</code>, calculated as if <code>r</code> is the explicit receiver, in order of the receiver priority (see the <a href="#a-call-with-an-explicit-receiver">corresponding section</a>);</span></li>
<li><span class="sentence">Top-level non-extension functions named <code>f</code>, in the order of:</span>
<ol type="a">
<li><span class="sentence">Functions explicitely imported into current file;</span></li>
<li><span class="sentence">Functions declared in the same package;</span></li>
<li><span class="sentence">Functions star-imported into current file;</span></li>
<li><span class="sentence">Implicitly imported functions (either Kotlin standard library or platform-specific ones).</span></li>
</ol></li>
</ol>
<div class="paragraph">
<p><span class="sentence">When analyzing these sets, the <strong>first</strong> set which contains <strong>any</strong> function with the corresponding name and conforming types is picked.</span></p>
</div>
<h3 id="calls-with-named-parameters">Calls with named parameters</h3>
<div class="paragraph">
<p><span class="sentence">Most of the calls in Kotlin may use named parameters in call expressions, e.g., <code>f(a = 2)</code>, where <code>a</code> is a parameter specified in the declaration of <code>f</code>. </span><span class="sentence">Such calls are treated the same way as normal calls, but the overload resolution sets are filtered to only contain callables which have matching formal parameters for all named parameters from the call.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: for properties called via <code>invoke</code> convention, the named parameters must be present in the declaration of the <code>invoke</code> operator function.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Unlike positional arguments, named arguments are matched by name directly to their respective formal parameters; this matching is performed separately for each function candidate. </span><span class="sentence">While the number of defaults (see <a href="#choosing-the-most-specific-function-from-the-overload-candidate-set">the MSC selection process</a>) does affect resolution process, the fact that some argument was or was not mapped as a named argument does not affect this process in any way.</span></p>
</div>
<h3 id="calls-with-trailing-lambda-expressions">Calls with trailing lambda expressions</h3>
<div class="paragraph">
<p><span class="sentence">A call expression may have a single lambda expression placed outside of the argument list parentheses or even completely replacing them (see [this section][Call expression] for further details). </span><span class="sentence">This has no effect on the overload resolution process, aside from the argument reordering which may happen because of variable argument parameters or parameters with defaults.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example: this means that calls <code>f(1,2) { g() }</code> and <code>f(1,2, body = { g() })</code> are completely equivalent w.r.t. the overload resolution, assuming <code>body</code> is the name of the last formal parameter of <code>f</code>.</span></p>
</div>
</blockquote>
<h3 id="calls-with-specified-type-parameters">Calls with specified type parameters</h3>
<div class="paragraph">
<p><span class="sentence">A call expression may have a type argument list explicitly specified before the argument list (see [this section][Call expression] for further details).. </span><span class="sentence">In this case all the potential overload sets only include callables which contain exactly the same number of formal type parameters at declaration site. </span><span class="sentence">In case of a property callable via <code>invoke</code> convention, type parameters must be present at the <code>invoke</code> operator function declaration.</span></p>
</div>
<h3 id="determining-function-applicability-for-a-specific-call">Determining function applicability for a specific call</h3>
<h4 id="rationale">Rationale</h4>
<div class="paragraph">
<p><span class="sentence">A function is <em>applicable</em> for a specific call if and only if the function parameters may be assigned the values of the arguments specified at call site and all type constraints of the function hold.</span></p>
</div>
<h4 id="description">Description</h4>
<div class="paragraph">
<p><span class="sentence">Determining function applicability for a specific call is a [type constraint][Type constraints] problem. </span><span class="sentence">First, for every non-lambda argument of the function supplied in the call, type inference is performed. </span><span class="sentence">Lambda arguments are excluded, as their type inference needs the results of overload resolution to finish.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Second, the following constraint system is built:</span></p>
</div>
<ul>
<li><span class="sentence">For every non-lambda parameter inferred to have type <span class="math inline">\(T_i\)</span>, corresponding to the function argument of type <span class="math inline">\(U_j\)</span>, a constraint <span class="math inline">\(T_i &lt;: U_j\)</span> is constructed;</span></li>
<li><span class="sentence">All declaration-site type constraints for the function are also added to the constraint system;</span></li>
<li><span class="sentence">For every lambda parameter with the number of lambda arguments known to be <span class="math inline">\(K\)</span>, corresponding to the function argument of type <span class="math inline">\(U_m\)</span>, a special constraint of the form <span class="math inline">\(R(L_1, \ldots, L_K) &lt;: U_m\)</span> is added to the constraint system, where <span class="math inline">\(R, L_1, \ldots, L_K\)</span> are fresh variables;</span></li>
<li><span class="sentence">For each lambda parameter with an unknown number of lambda arguments (that is, being equal to 0 or 1), a special constraint of the form <span class="math inline">\(kotlin.Function &lt;: U_m\)</span> is added to the constraint system, where <span class="math inline">\(kotlin.Function\)</span> is the common base of all functional types <span><span class="TODO">(TODO(whatâ€™s the spec name?))</span><span class="TODO-marker">*</span></span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If this constraint system is sound, the function is applicable for the call. </span><span class="sentence">Only applicable functions are considered for the next step: finding the most specific overload candidate from the candidate set.</span></p>
</div>
<h3 id="choosing-the-most-specific-function-from-the-overload-candidate-set">Choosing the most specific function from the overload candidate set</h3>
<h4 id="rationale-1">Rationale</h4>
<div class="paragraph">
<p><span class="sentence">The main rationale in choosing the most specific function from the overload candidate set is the following:</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">The most specific function can forward itself to any other function from the overload candidate set, while the opposite is not true.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">If there are several functions with this property, none of them are the most specific and an ambiguity error should be reported by the compiler.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Consider the following example with two functions:</span></p>
</div>
<div class="sourceCode" id="cb20"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">fun</span> <span class="fu">f</span>(<span class="va">arg</span>: <span class="dt">Int</span>, <span class="va">arg2</span>: <span class="dt">String</span>) {}        <span class="co">// (1)</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="kw">fun</span> <span class="fu">f</span>(<span class="va">arg</span>: <span class="dt">Any?</span>, <span class="va">arg2</span>: <span class="dt">CharSequence</span>) {} <span class="co">// (2)</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">...</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">f(<span class="dv">2</span>, <span class="st">&quot;Hello&quot;</span>)</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">Both functions (1) and (2) are applicable for the call, but function (1) could easily call function (2) by forwarding both arguments into it, and the reverse is impossible. </span><span class="sentence">As a result, function (1) is more specific of the two.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The following snippet should explain this in more detail.</span></p>
</div>
<div class="sourceCode" id="cb21"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">fun</span> <span class="fu">f1</span>(<span class="va">arg</span>: <span class="dt">Int</span>, <span class="va">arg2</span>: <span class="dt">String</span>) {</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">    f2(arg, arg2) <span class="co">// valid: can forward both arguments</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="kw">fun</span> <span class="fu">f2</span>(<span class="va">arg</span>: <span class="dt">Any?</span>, <span class="va">arg2</span>: <span class="dt">CharSequence</span>) {</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">    f1(arg, arg2) <span class="co">// invalid: function f1 is not applicable</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">The rest of this section will try to clarify this mechanism in more detail.</span></p>
</div>
<h4 id="description-1">Description</h4>
<div class="paragraph">
<p><span class="sentence">When an overload resolution set <span class="math inline">\(S\)</span> is selected and it contains more than one callable, the next step is to choose the most appropriate candidate from these callables.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Firts, <span class="math inline">\(S\)</span> is divided into two subsets: callables with type parameters (generic callables) and callables without such (non-generic callables). </span><span class="sentence">If there are any non-generic applicable candidates, the choice is limited only to the non-generic subset. </span><span class="sentence">Otherwise, we consider the generic subset.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The selection process uses the [type constraint][Type constraints] system of Kotlin, in a way similar to the process of <a href="#determining-function-applicability-for-a-specific-call">determining function applicability</a>. </span><span class="sentence">For every two distinct members of the candidate set <span class="math inline">\(F_1\)</span> and <span class="math inline">\(F_2\)</span>, the following constraint system is constructed and solved:</span></p>
</div>
<ul>
<li><span class="sentence">For every non-default argument of the call, the corresponding value parameter types <span class="math inline">\(X_1, X_2, X_3, \ldots, X_N\)</span> of <span class="math inline">\(F_1\)</span> and <span class="math inline">\(Y_1, Y_2, Y_3, \ldots, Y_N\)</span> of <span class="math inline">\(F_2\)</span>, a type constraint <span class="math inline">\(X_K &lt;: Y_K\)</span> is built. </span><span class="sentence">During construction of these constraints, all type parameters <span class="math inline">\(T_1, T_2, \ldots, T_M\)</span> of <span class="math inline">\(F_1\)</span> are considered bound to fresh type variables <span class="math inline">\(T^{\sim}_1, T^{\sim}_2, \ldots, T^{\sim}_M\)</span>, and all type parameters of <span class="math inline">\(F_2\)</span> are considered free;</span></li>
<li><span class="sentence">All declaration-site type constraints of <span class="math inline">\(X_1, X_2, X_3, \ldots, X_N\)</span> and <span class="math inline">\(Y_1, Y_2, Y_3, \ldots, Y_N\)</span> are also added to the constraint system.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If the resulting constraint system is sound, it means that <span class="math inline">\(F_1\)</span> is equally or more applicable than <span class="math inline">\(F_2\)</span> as an overload candidate (aka applicability criteria). </span><span class="sentence">The check is then repeated with <span class="math inline">\(F_1\)</span> and <span class="math inline">\(F_2\)</span> swapped. </span><span class="sentence">If <span class="math inline">\(F_1\)</span> is equally or more applicable than <span class="math inline">\(F_2\)</span> and <span class="math inline">\(F_2\)</span> is equally or more applicable than <span class="math inline">\(F_1\)</span>, this means that the two callables are equally applicable and an additional decision step is needed to choose the most specific overload candidate.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Can we have two callables incomparable w.r.t. applicability criteria? </span><span class="sentence">What do we do then?)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">All members of the overload candidate set are ranked according to the applicability criteria. </span><span class="sentence">If there are several callables which are more applicable than all other candidates and equally applicable to each other, an additional step is performed.</span></p>
</div>
<ul>
<li><span class="sentence">For each candidate, we count the number of default parameters <em>not</em> specified in the call (i.e., the number of parameters for which we use the default value);</span></li>
<li><span class="sentence">The candidate with the least number of non-specified default parameters is a more specific candidate;</span></li>
<li><span class="sentence">If the number of non-specified default parameters is equal for several candidates, the candidate having any variable-argument parameters is less specific than any candidate without them.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If after this additional step there are still several candidates that are equally applicable for the call, this is an <strong>overload ambiguity</strong> which must be reported as a compiler error.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: unlike the applicability test, the candidate comparison constraint system is <strong>not</strong> based on the actuall call, meaning that, when comparing two candidates, only constraints visible at <em>declaration site</em> apply.</span></p>
</div>
</blockquote>
<h3 id="about-type-inference">About type inference</h3>
<div class="paragraph">
<p><span class="sentence"><a href="#type-inference">Type inference</a> in Kotlin is a pretty complicated process, which is performed after resolving all the overload candidates. </span><span class="sentence">Due to the complexity of the process, type inference may not affect the way overload resolution candidate is picked up.</span></p>
</div>
<h4 id="todos-1">TODOs</h4>
<ul>
<li><span class="sentence">Property business</span></li>
<li><span class="sentence">Function types (type system section?)</span></li>
<li><span class="sentence">Definition of an â€œapplicable functionâ€</span></li>
<li><span class="sentence">Definition of â€œtype parameter levelâ€</span></li>
<li><span class="sentence">Calls with named parameters <code>f(x = 2)</code></span></li>
<li><span class="sentence">Calls with trailing lambda without parameter type</span>
<ul>
<li><span class="sentence">Lambdas with parameter types seem to be covered (<strong>nope, they are not</strong>)</span></li>
</ul></li>
<li><span class="sentence">Calls with specified type parameters <code>f&lt;Double&gt;(3)</code></span></li>
<li><span class="sentence">! </span><span class="sentence">Constructors and companion object <code>invoke</code> (clash with functions)</span></li>
<li><span class="sentence">! </span><span class="sentence">Singleton objects (clash with properties)</span></li>
<li><span class="sentence">! </span><span class="sentence">Enum constants (clash with properties)</span></li>
</ul>
<h2 id="concurrency">Concurrency</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h2 id="coroutines">Coroutines</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h2 id="annotations">Annotations</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h2 id="documentation-comments">Documentation comments</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h2 id="fubar">FUBAR</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h2 id="exceptions">Exceptions</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
</body>
</html>
